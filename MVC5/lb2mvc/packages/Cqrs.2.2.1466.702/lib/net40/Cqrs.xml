<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Cqrs</name>
    </assembly>
    <members>
        <member name="T:Cqrs.Authentication.AuthenticationTokenHelper">
            <summary>
            A helper for setting and retrieving authentication tokens of type 
            <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/>, <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn"/>, <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn"/>
            or <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsnAndCompanyRsn"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.AuthenticationTokenHelper`1">
            <summary>
            A helper for setting and retrieving authentication tokens of type <typeparamref name="TAuthenticationToken"/>
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Authentication.IAuthenticationTokenHelper`1">
            <summary>
            A helper for setting and retrieving authentication tokens of type <typeparamref name="TAuthenticationToken"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Authentication.IAuthenticationTokenHelper`1.GetAuthenticationToken">
            <summary>
            Get the current <typeparamref name="TAuthenticationToken">authentication token</typeparamref> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.IAuthenticationTokenHelper`1.SetAuthenticationToken(`0)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="F:Cqrs.Authentication.AuthenticationTokenHelper`1.CacheKey">
            <summary>
            The key used to store the authentication token in the <see cref="P:Cqrs.Authentication.AuthenticationTokenHelper`1.Cache"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper`1.#ctor(cdmdotnet.StateManagement.IContextItemCollectionFactory)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Authentication.AuthenticationTokenHelper`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper`1.SetAuthenticationToken(`0)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper`1.GetAuthenticationToken">
            <summary>
            Get the current <typeparamref name="TAuthenticationToken">authentication token</typeparamref> for the current context/request.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.AuthenticationTokenHelper`1.Cache">
            <summary>
            Get or set the Cache.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.#ctor(cdmdotnet.StateManagement.IContextItemCollectionFactory)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Authentication.AuthenticationTokenHelper"/>
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.SetAuthenticationToken(Cqrs.Authentication.ISingleSignOnTokenWithUserRsnAndCompanyRsn)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.SetAuthenticationToken(Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.SetAuthenticationToken(Cqrs.Authentication.ISingleSignOnTokenWithUserRsn)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{Cqrs#Authentication#ISingleSignOnTokenWithUserRsn}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{Cqrs#Authentication#ISingleSignOnTokenWithCompanyRsn}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.AuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{Cqrs#Authentication#ISingleSignOnTokenWithUserRsnAndCompanyRsn}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsnAndCompanyRsn">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.DefaultAuthenticationTokenHelper">
            <summary>
            A helper for setting and retrieving authentication tokens of type 
            <see cref="T:Cqrs.Authentication.SingleSignOnToken"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn"/>
            <see cref="T:System.Int32"/>, <see cref="T:System.Guid"/> or <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.#ctor(cdmdotnet.StateManagement.IContextItemCollectionFactory)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Authentication.DefaultAuthenticationTokenHelper"/>
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.SetAuthenticationToken(Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.SetAuthenticationToken(Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.SetAuthenticationToken(Cqrs.Authentication.SingleSignOnTokenWithUserRsn)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{Cqrs#Authentication#SingleSignOnTokenWithUserRsn}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.SetAuthenticationToken(System.Guid)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.SetAuthenticationToken(System.Int32)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.SetAuthenticationToken(System.String)">
            <summary>
            Set the provided <paramref name="token"/> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{Cqrs#Authentication#SingleSignOnTokenWithCompanyRsn}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{Cqrs#Authentication#SingleSignOnTokenWithUserRsnAndCompanyRsn}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{System#Int32}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:System.Int32">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{System#Guid}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:System.Guid">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.DefaultAuthenticationTokenHelper.Cqrs#Authentication#IAuthenticationTokenHelper{System#String}#GetAuthenticationToken">
            <summary>
            Get the current <see cref="T:System.String">authentication token</see> for the current context/request.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.DefaultSingleSignOnTokenFactory">
            <summary>
            A Factory for creating new authentication tokens of type <see cref="T:Cqrs.Authentication.SingleSignOnToken"/>
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.SingleSignOnTokenFactory`1">
            <summary>
            A factory for creating new authentication tokens of type <typeparamref name="TSingleSignOnToken"/>.
            </summary>
            <typeparam name="TSingleSignOnToken">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/>.</typeparam>
        </member>
        <member name="T:Cqrs.Authentication.ISingleSignOnTokenFactory`1">
            <summary>
            A factory for creating new authentication tokens of type <typeparamref name="TSingleSignOnToken"/>.
            </summary>
            <typeparam name="TSingleSignOnToken">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/>.</typeparam>
        </member>
        <member name="M:Cqrs.Authentication.ISingleSignOnTokenFactory`1.CreateNew(System.Int32)">
            <summary>
            Create a new <typeparamref name="TSingleSignOnToken"/>.
            </summary>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/></param>
        </member>
        <member name="M:Cqrs.Authentication.ISingleSignOnTokenFactory`1.RenewTokenExpiry(`0,System.Int32)">
            <summary>
            Renew the value of <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/>.
            </summary>
            <param name="token">The <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> to renew.</param>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/></param>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenFactory`1.CreateNew(System.Int32)">
            <summary>
            Create a new <typeparamref name="TSingleSignOnToken"/>.
            </summary>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/></param>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenFactory`1.RenewTokenExpiry(`0,System.Int32)">
            <summary>
            Renew the value of <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/>.
            </summary>
            <param name="token">The <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> to renew.</param>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/></param>
        </member>
        <member name="T:Cqrs.Authentication.IDefaultSingleSignOnTokenFactory">
            <summary>
            A Factory for creating new authentication tokens of type <see cref="T:Cqrs.Authentication.SingleSignOnToken"/>
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.IDefaultSingleSignOnTokenFactory.RenewTokenExpiry(Cqrs.Authentication.ISingleSignOnToken,System.Int32)">
            <summary>
            Renew the value of <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/>.
            </summary>
            <param name="token">The <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> to renew.</param>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/></param>
        </member>
        <member name="M:Cqrs.Authentication.DefaultSingleSignOnTokenFactory.Cqrs#Authentication#IDefaultSingleSignOnTokenFactory#RenewTokenExpiry(Cqrs.Authentication.ISingleSignOnToken,System.Int32)">
            <summary>
            Renew the value of <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/>.
            </summary>
            <param name="token">The <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> to renew.</param>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/>.</param>
        </member>
        <member name="M:Cqrs.Authentication.DefaultSingleSignOnTokenFactory.RenewTokenExpiry``1(``0,System.Int32)">
            <summary>
            Renew the value of <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/>.
            </summary>
            <param name="token">The <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> to renew.</param>
            <param name="timeoutInMinutes">The amount of time in minutes to set the <see cref="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry"/> to. This is from <see cref="P:System.DateTime.UtcNow"/>.</param>
        </member>
        <member name="T:Cqrs.Authentication.BasicTokenResolver">
            <summary>
            Resolves basic, known parameter types when serialising with WCF.
            </summary>
        </member>
        <member name="T:Cqrs.Services.IServiceParameterResolver">
            <summary>
            Resolves parameter types when serialising with WCF.
            </summary>
        </member>
        <member name="M:Cqrs.Services.IServiceParameterResolver.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
            <summary>
            Indicates if the provided <paramref name="typeName"/> is resolvable.
            </summary>
        </member>
        <member name="M:Cqrs.Services.IServiceParameterResolver.TryResolveType(System.Type,System.Type,System.Runtime.Serialization.DataContractResolver,System.Xml.XmlDictionaryString@,System.Xml.XmlDictionaryString@)">
            <summary>
            Returns the <see cref="T:System.Type"/> if the <paramref name="typeName"/> is resolvable.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.BasicTokenResolver.TryResolveType(System.Type,System.Type,System.Runtime.Serialization.DataContractResolver,System.Xml.XmlDictionaryString@,System.Xml.XmlDictionaryString@)">
            <summary>
            Indicates if the provided <paramref name="dataContractType"/> is of type <see cref="T:System.Guid"/>, <see cref="T:System.Nullable`1"/>, <see cref="T:System.Int32"/>, <see cref="T:System.Nullable`1"/>, <see cref="T:System.String"/>
            OR if it is other resolvable.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.BasicTokenResolver.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
            <summary>
            Returns the <see cref="T:System.Type"/> if the <paramref name="typeName"/> is resolvable or if it is 
            of type <see cref="T:System.Guid"/>, <see cref="T:System.Nullable`1"/>, <see cref="T:System.Int32"/>, <see cref="T:System.Nullable`1"/> and <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn">
            <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn"/> and <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn"/>
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.SingleSignOnToken">
            <summary>
            An authentication token with expiry and an issue time information.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.ISingleSignOnToken">
            <summary>
            An authentication token with expiry and an issue time information.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.ISingleSignOnToken.Serialise">
            <summary>
            Serialises this token to a string.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.ISingleSignOnToken.Token">
            <summary>
            The authentication token.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.ISingleSignOnToken.TimeOfExpiry">
            <summary>
            The <see cref="T:System.DateTime"/> this token should expire.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.ISingleSignOnToken.DateIssued">
            <summary>
            The <see cref="T:System.DateTime"/> this token was issued.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnToken.Serialise">
            <summary>
            Returns <see cref="P:Cqrs.Authentication.SingleSignOnToken.Token"/>.
            </summary>
            <returns><see cref="P:Cqrs.Authentication.SingleSignOnToken.Token"/>.</returns>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnToken.Token">
            <summary>
            The authentication token.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnToken.TimeOfExpiry">
            <summary>
            The <see cref="T:System.DateTime"/> this token should expire.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnToken.DateIssued">
            <summary>
            The <see cref="T:System.DateTime"/> this token was issued.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsnAndCompanyRsn">
            <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn"/> and <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn"/>
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn">
            <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> that includes an identifiable <see cref="P:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn.CompanyRsn"/> to optimise the hits of the <see cref="T:Cqrs.DataStores.IDataStore`1">DataStores</see> by including data you most likely need.
            As such, if not used correctly, this can expose identifiable information.
            It is suggested the service layer populates this before sending commands as part of authorisation/authentication.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn.CompanyRsn">
            <summary>
            The Rsn of the company the user doing the operation is operating on.
            When used in a system where a single user can have access to multiple companies, this is not the company the user belongs to, but the company it is operating on.
            When used by an external 3rd party this is the all in context of the person being impersonated, not the 3rd party system itself.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn">
            <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> that includes an identifiable <see cref="P:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn.UserRsn"/> to optimise the hits of the <see cref="T:Cqrs.DataStores.IDataStore`1">DataStores</see> by including data you most likely need.
            As such, if not used correctly, this can expose identifiable information.
            It is suggested the service layer populates this before sending commands as part of authorisation/authentication.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn.UserRsn">
            <summary>
            The Rsn of the user doing the operation. When used by an external 3rd party this is the person being impersonated, not the 3rd party system itself.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.Serialise">
            <summary>
            Returns <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.CompanyRsn"/> and <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.UserRsn"/>.
            </summary>
            <returns><see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.CompanyRsn"/> and <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.UserRsn"/>.</returns>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.CompanyRsn">
            <summary>
            The Rsn of the company the user doing the operation is operating on.
            When used in a system where a single user can have access to multiple companies, this is not the company the user belongs to, but the company it is operating on.
            When used by an external 3rd party this is the all in context of the person being impersonated, not the 3rd party system itself.
            </summary>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.UserRsn">
            <summary>
            The Rsn of the user doing the operation. When used by an external 3rd party this is the person being impersonated, not the 3rd party system itself.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn">
            <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> that includes an identifiable <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn.CompanyRsn"/> to optimise the hits of the <see cref="T:Cqrs.DataStores.IDataStore`1">DataStores</see> by including data you most likely need.
            As such, if not used correctly, this can expose identifiable information.
            It is suggested the service layer populates this before sending commands as part of authorisation/authentication.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn.Serialise">
            <summary>
            Returns <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn.CompanyRsn"/>.
            </summary>
            <returns><see cref="P:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn.CompanyRsn"/>.</returns>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn.CompanyRsn">
            <summary>
            The Rsn of the company the user doing the operation is operating on.
            When used in a system where a single user can have access to multiple companies, this is not the company the user belongs to, but the company it is operating on.
            When used by an external 3rd party this is the all in context of the person being impersonated, not the 3rd party system itself.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn">
            <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnToken"/> that includes an identifiable <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsn.UserRsn"/> to optimise the hits of the <see cref="T:Cqrs.DataStores.IDataStore`1">DataStores</see> by including data you most likely need.
            As such, if not used correctly, this can expose identifiable information.
            It is suggested the service layer populates this before sending commands as part of authorisation/authentication.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenWithUserRsn.Serialise">
            <summary>
            Returns <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsn.UserRsn"/>.
            </summary>
            <returns><see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsn.UserRsn"/>.</returns>
        </member>
        <member name="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsn.UserRsn">
            <summary>
            The Rsn of the user doing the operation. When used by an external 3rd party this is the person being impersonated, not the 3rd party system itself.
            </summary>
        </member>
        <member name="T:Cqrs.Authentication.SingleSignOnTokenResolver">
            <summary>
            Resolves parameter types when serialising with WCF of <see cref="T:System.Type"/>
            <see cref="T:Cqrs.Authentication.SingleSignOnToken"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn"/> and <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn"/>
            </summary>
        </member>
        <member name="T:Cqrs.Services.ISingleSignOnTokenResolver">
            <summary>
            Resolves parameter type when serialising with WCF.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenResolver.TryResolveType(System.Type,System.Type,System.Runtime.Serialization.DataContractResolver,System.Xml.XmlDictionaryString@,System.Xml.XmlDictionaryString@)">
            <summary>
            Indicates if the provided <paramref name="dataContractType"/> is of type <see cref="T:Cqrs.Authentication.SingleSignOnToken"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn"/>
            OR if it is other resolvable.
            </summary>
        </member>
        <member name="M:Cqrs.Authentication.SingleSignOnTokenResolver.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
            <summary>
            Returns the <see cref="T:System.Type"/> if the <paramref name="typeName"/> is resolvable or if it is 
            of type <see cref="T:Cqrs.Authentication.SingleSignOnToken"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn"/>, <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn"/> and <see cref="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn"/>
            </summary>
        </member>
        <member name="T:Cqrs.Bus.BusHelper">
            <summary>
            A helper for command and event buses that also caches <see cref="T:Cqrs.Configuration.IConfigurationManager"/> look ups.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.IBusHelper">
            <summary>
            A helper for command and event buses.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.IBusHelper.IsEventRequired(System.Type)">
            <summary>
            Checks if a white-list or black-list approach is taken, then checks the <see cref="T:Cqrs.Configuration.IConfigurationManager"/> to see if a key exists defining if the event is required or not.
            If the event is required and it cannot be resolved, an error will be raised.
            Otherwise the event will be marked as processed.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of the message being processed.</param>
        </member>
        <member name="M:Cqrs.Bus.IBusHelper.IsEventRequired(System.String)">
            <summary>
            Checks if a white-list or black-list approach is taken, then checks the <see cref="T:Cqrs.Configuration.IConfigurationManager"/> to see if a key exists defining if the event is required or not.
            If the event is required and it cannot be resolved, an error will be raised.
            Otherwise the event will be marked as processed.
            </summary>
            <param name="configurationKey">The configuration key to check.</param>
        </member>
        <member name="M:Cqrs.Bus.IBusHelper.BuildTelemeteredActionHandler``2(cdmdotnet.Logging.ITelemetryHelper,System.Action{``0},System.Boolean,System.String)">
            <summary>
            Build a message handler that implements telemetry capturing as well as off thread handling.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.IBusHelper.BuildActionHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Build a message handler that implements telemetry capturing as well as off thread handling.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.#ctor(Cqrs.Configuration.IConfigurationManager)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Bus.BusHelper"/>
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.RefreshCachedChecks">
            <summary>
            Refreshes <see cref="P:Cqrs.Bus.BusHelper.EventBlackListProcessing"/> and every item currently in <see cref="P:Cqrs.Bus.BusHelper.CachedChecks"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.StartRefreshCachedChecks">
            <summary>
            Starts <see cref="M:Cqrs.Bus.BusHelper.RefreshCachedChecks"/> in a <see cref="T:System.Threading.Tasks.Task"/> on a one second loop.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.IsEventRequired(System.Type)">
            <summary>
            Checks if a white-list or black-list approach is taken, then checks the <see cref="T:Cqrs.Configuration.IConfigurationManager"/> to see if a key exists defining if the event is required or not.
            If the event is required and it cannot be resolved, an error will be raised.
            Otherwise the event will be marked as processed.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of the message being processed.</param>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.IsEventRequired(System.String)">
            <summary>
            Checks if a white-list or black-list approach is taken, then checks the <see cref="T:Cqrs.Configuration.IConfigurationManager"/> to see if a key exists defining if the event is required or not.
            If the event is required and it cannot be resolved, an error will be raised.
            Otherwise the event will be marked as processed.
            </summary>
            <param name="configurationKey">The configuration key to check.</param>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.BuildTelemeteredActionHandler``2(cdmdotnet.Logging.ITelemetryHelper,System.Action{``0},System.Boolean,System.String)">
            <summary>
            Build a message handler that implements telemetry capturing as well as off thread handling.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.BusHelper.BuildActionHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Build a message handler that implements telemetry capturing as well as off thread handling.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.BusHelper.ConfigurationManager">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Configuration.IConfigurationManager"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.BusHelper.CachedChecks">
            <summary>
            A collection of <see cref="T:System.Tuple`2"/> holding the configurations value (always a <see cref="T:System.Boolean"/>) and the <see cref="T:System.DateTime"/>
            The value was last checked, keyed by it's configuration key.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.BusHelper.EventBlackListProcessing">
            <summary>
            The current value of "Cqrs.MessageBus.BlackListProcessing" from <see cref="P:Cqrs.Bus.BusHelper.ConfigurationManager"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Exceptions.NoHandlersRegisteredException">
            <summary>
            The <see cref="T:System.Exception"/> that is thrown when no <see cref="T:Cqrs.Messages.IHandler"/> if found for a given <see cref="T:Cqrs.Messages.IMessage"/>, but more than one was expected.
            </summary>
        </member>
        <member name="M:Cqrs.Exceptions.NoHandlersRegisteredException.#ctor(System.Type)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Exceptions.NoHandlersRegisteredException"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> that expected more than one <see cref="T:Cqrs.Messages.IHandler"/>.</param>
        </member>
        <member name="M:Cqrs.Exceptions.NoHandlersRegisteredException.#ctor(System.String)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Exceptions.NoHandlersRegisteredException"/> with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:Cqrs.Exceptions.MultipleHandlersRegisteredException">
            <summary>
            The <see cref="T:System.Exception"/> that is thrown when more than one <see cref="T:Cqrs.Messages.IHandler"/> if found for a given <see cref="T:Cqrs.Messages.IMessage"/> that only expects one.
            </summary>
        </member>
        <member name="M:Cqrs.Exceptions.MultipleHandlersRegisteredException.#ctor(System.Type)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Exceptions.MultipleHandlersRegisteredException"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> that expected only one <see cref="T:Cqrs.Messages.IHandler"/>.</param>
        </member>
        <member name="M:Cqrs.Exceptions.MultipleHandlersRegisteredException.#ctor(System.String)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Exceptions.MultipleHandlersRegisteredException"/> with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:Cqrs.Bus.QueuedCommandBusReceiver`1">
            <summary>
            Receives instances of a <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus, places them into one of several internal concurrent queues and then processes the commands one at a time per queue.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Commands.ICommandReceiver`1">
            <summary>
            Receives instances of a <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Commands.ICommandReceiver">
            <summary>
            Receives instances of a <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Commands.ICommandReceiver.Start">
            <summary>
            Starts listening and processing instances of <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Commands.ICommandReceiver`1.ReceiveCommand(Cqrs.Commands.ICommand{`0})">
            <summary>
            Receives a <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.QueuedCommandBusReceiver`1.#ctor(Cqrs.Authentication.IAuthenticationTokenHelper{`0},cdmdotnet.Logging.ICorrelationIdHelper,cdmdotnet.Logging.ILogger,Cqrs.Configuration.IConfigurationManager,Cqrs.Bus.IBusHelper)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Bus.QueuedCommandBusReceiver`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.QueuedCommandBusReceiver`1.EnqueueCommand(System.String,Cqrs.Commands.ICommand{`0})">
            <summary>
            Places the provided <paramref name="command"/> into the appropriate queue in the <see cref="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker"/>.
            </summary>
            <param name="targetQueueName">The name of the target queue to place the command into</param>
            <param name="command">The <see cref="T:Cqrs.Commands.ICommand`1"/> to handle.</param>
        </member>
        <member name="M:Cqrs.Bus.QueuedCommandBusReceiver`1.CreateQueueAndAttachListenerIfNotExist(System.String)">
            <summary>
            Checks if the queue exists, if it doesn't it creates a new queue in <see cref="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker"/> and then starts a separate <see cref="T:System.Threading.Thread"/> running <see cref="M:Cqrs.Bus.QueuedCommandBusReceiver`1.DequeuAndProcessCommand(System.String)"/>.
            </summary>
            <param name="queueName">The name of the queue.</param>
        </member>
        <member name="M:Cqrs.Bus.QueuedCommandBusReceiver`1.DequeuAndProcessCommand(System.String)">
            <summary>
            Infinitely runs a loop checking if the queue exists in <see cref="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker"/>
            and then dequeues <see cref="T:Cqrs.Commands.ICommand`1"/> one at a time, pausing for 0.1 seconds between loops.
            </summary>
            <param name="queueName">The name of the queue.</param>
        </member>
        <member name="M:Cqrs.Bus.QueuedCommandBusReceiver`1.ReceiveCommand(Cqrs.Commands.ICommand{`0})">
            <summary>
            Receives a <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.QueuedCommandBusReceiver`1.Start">
            <summary>
            Starts listening and processing instances of <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker">
            <summary>
            The queues keyed by an identifier.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTrackerLock">
            <summary>
            A <see cref="T:System.Threading.ReaderWriterLockSlim"/> for providing a lock mechanism around the main <see cref="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.AuthenticationTokenHelper">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Authentication.IAuthenticationTokenHelper`1"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.CorrelationIdHelper">
            <summary>
            Gets or sets the <see cref="T:cdmdotnet.Logging.ICorrelationIdHelper"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.Logger">
            <summary>
            Gets or sets the <see cref="T:cdmdotnet.Logging.ILogger"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.ConfigurationManager">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Configuration.IConfigurationManager"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.BusHelper">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Bus.IBusHelper"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.Routes">
            <summary>
            Gets or sets the routes or handlers that will be executed as the commands arrive.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueCount">
            <summary>
            The current number of queues in <see cref="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueNames">
            <summary>
            Gets the names of all queues in <see cref="P:Cqrs.Bus.QueuedCommandBusReceiver`1.QueueTracker"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.ICommandHandlerRegistrar">
            <summary>
            Registers command handlers that listen and respond to commands.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.IHandlerRegistrar">
            <summary>
            Registers event or command handlers that listen and respond to events or commands.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.IHandlerRegistrar.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)">
            <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
            <remarks>
            In many cases the <paramref name="targetedType"/> will be the handler class itself, what you actually want is the target of what is being updated.
            </remarks>
        </member>
        <member name="M:Cqrs.Bus.IHandlerRegistrar.RegisterHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.IEventHandlerRegistrar">
            <summary>
            Registers event handlers that listen and respond to events.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.IEventHandlerRegistrar.RegisterGlobalEventHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event handler that will listen and respond to all events.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.FileBasedLastEventProcessedStore">
            <summary>
            Indicates the position in a store where the stream has been read up to by storing the value in a file.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.IStoreLastEventProcessed">
            <summary>
            Indicates the position in a store where the stream has been read up to.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.IStoreLastEventProcessed.EventLocation">
            <summary>
            The location within the store where the stream has been read up to.
            </summary>
        </member>
        <member name="F:Cqrs.Bus.FileBasedLastEventProcessedStore.AppSettingsKey">
            <summary>
            The configuration setting that holds the location of file to store position information in.
            </summary>
        </member>
        <member name="F:Cqrs.Bus.FileBasedLastEventProcessedStore.AppSettingsDefaultValue">
            <summary>
            The default location of the file to store position information in.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.FileBasedLastEventProcessedStore.#ctor(Cqrs.Configuration.IConfigurationManager)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Bus.FileBasedLastEventProcessedStore"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.FileBasedLastEventProcessedStore.FileName">
            <summary>
            The relative or absolute path of the file to store the current location in
            </summary>
        </member>
        <member name="P:Cqrs.Bus.FileBasedLastEventProcessedStore.EventLocation">
            <summary>
            Reads and writes the location within the store where the stream has been read up to <see cref="P:Cqrs.Bus.FileBasedLastEventProcessedStore.FileName"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.Route">
            <summary>
            A collection of <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.Route.Handlers">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.RouteHandlerDelegate">
            <summary>
            Information about a <see cref="T:Cqrs.Bus.Route"/> delegate.
            </summary>
            <remarks>Remarkably similar to <see cref="T:Cqrs.Configuration.HandlerDelegate"/></remarks>
        </member>
        <member name="T:Cqrs.Configuration.HandlerDelegate`1">
            <summary>
            Information about a delegate.
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.HandlerDelegate`1.Delegate">
            <summary>
            The delegate that gets executed.
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.HandlerDelegate`1.TargetedType">
            <summary>
            The <see cref="T:System.Type"/> of the targeted object that <see cref="P:Cqrs.Configuration.HandlerDelegate`1.Delegate"/> operates on.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.RouteManager">
            <summary>
            Manages <see cref="T:Cqrs.Bus.Route">routes</see>.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.#ctor">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Bus.RouteManager"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)">
            <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.RegisterHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.RegisterGlobalEventHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event handler that will listen and respond to all events.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.GetSingleHandler``1(System.Boolean)">
            <summary>
            Gets the single <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> expected for handling <typeparamref name="TMessage"/>.
            </summary>
            <typeparam name="TMessage">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> to find a <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> for.</typeparam>
            <param name="throwExceptionOnNoRouteHandlers">If true will throw an <see cref="T:System.Exception"/> if no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> found.</param>
            <exception cref="T:Cqrs.Exceptions.MultipleCommandHandlersRegisteredException">If more than one <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/>.</exception>
            <exception cref="T:Cqrs.Exceptions.NoCommandHandlerRegisteredException">If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
            <exception cref="T:System.InvalidOperationException">
            If more than one <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is not an <see cref="T:Cqrs.Commands.ICommand`1"/> OR
            If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is not an <see cref="T:Cqrs.Commands.ICommand`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.GetSingleHandler``1(``0,System.Boolean)">
            <summary>
            Gets the single <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> expected for handling <typeparamref name="TMessage"/>.
            </summary>
            <typeparam name="TMessage">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> to find a <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> for.</typeparam>
            <param name="message">The <typeparamref name="TMessage"/> to find a <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> for. </param>
            <param name="throwExceptionOnNoRouteHandlers">If true will throw an <see cref="T:System.Exception"/> if no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> found.</param>
            <exception cref="T:Cqrs.Exceptions.MultipleCommandHandlersRegisteredException">If more than one <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/>.</exception>
            <exception cref="T:Cqrs.Exceptions.NoCommandHandlerRegisteredException">If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
            <exception cref="T:System.InvalidOperationException">
            If more than one <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is not an <see cref="T:Cqrs.Commands.ICommand`1"/> OR
            If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is not an <see cref="T:Cqrs.Commands.ICommand`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.GetHandlers``1(``0,System.Boolean)">
            <summary>
            Gets the collection <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> that are expected for handling <typeparamref name="TMessage"/>.
            </summary>
            <typeparam name="TMessage">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> to find a <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> for.</typeparam>
            <param name="message">The <typeparamref name="TMessage"/> to find a <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> for. </param>
            <param name="throwExceptionOnNoRouteHandlers">If true will throw an <see cref="T:System.Exception"/> if no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> found.</param>
            <exception cref="T:Cqrs.Exceptions.NoCommandHandlerRegisteredException">If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
            <exception cref="T:Cqrs.Exceptions.NoEventHandlerRegisteredException"> If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is an <see cref="T:Cqrs.Events.IEvent`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
            <exception cref="T:Cqrs.Exceptions.NoHandlerRegisteredException"> If no <see cref="T:Cqrs.Bus.RouteHandlerDelegate"/> is found and <typeparamref name="TMessage"/> is not either an <see cref="T:Cqrs.Commands.ICommand`1"/> or an <see cref="T:Cqrs.Events.IEvent`1"/> and <paramref name="throwExceptionOnNoRouteHandlers"/> is true.</exception>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.IsACommand``1(``0)">
            <summary>
            Checks if the provided <paramref name="message"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/>.
            </summary>
            <typeparam name="TMessage">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> to check.</typeparam>
            <param name="message">The <typeparamref name="TMessage"/> to check. </param>
            <returns>true if <paramref name="message"/> is an <see cref="T:Cqrs.Commands.ICommand`1"/>.</returns>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.IsACommand(System.Type)">
            <summary>
            Checks if the provided <paramref name="messageType"/> implements <see cref="T:Cqrs.Commands.ICommand`1"/>.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of object to check.</param>
            <returns>true if <paramref name="messageType"/> implements <see cref="T:Cqrs.Commands.ICommand`1"/>.</returns>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.IsAnEvent``1(``0)">
            <summary>
            Checks if the provided <paramref name="message"/> is an <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
            <typeparam name="TMessage">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> to check.</typeparam>
            <param name="message">The <typeparamref name="TMessage"/> to check. </param>
            <returns>true if <paramref name="message"/> is an <see cref="T:Cqrs.Events.IEvent`1"/>.</returns>
        </member>
        <member name="M:Cqrs.Bus.RouteManager.IsAnEvent(System.Type)">
            <summary>
            Checks if the provided <paramref name="messageType"/> implements <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
            <param name="messageType">The <see cref="T:System.Type"/> of object to check.</param>
            <returns>true if <paramref name="messageType"/> implements <see cref="T:Cqrs.Events.IEvent`1"/>.</returns>
        </member>
        <member name="P:Cqrs.Bus.RouteManager.Routes">
            <summary>
            The <see cref="T:Cqrs.Bus.Route"/> to execute per <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.RouteManager.GlobalEventRoute">
            <summary>
            A <see cref="T:Cqrs.Bus.Route"/> to execute for all <see cref="T:Cqrs.Events.IEvent`1"/>
            </summary>
        </member>
        <member name="T:Cqrs.Cache.CacheRepository`1">
            <summary>
            Uses <see cref="P:System.Runtime.Caching.MemoryCache.Default"/> to provide a caching mechanism to improve performance of a <see cref="T:Cqrs.Domain.IAggregateRepository`1"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Domain.IAggregateRepository`1">
            <summary>
            Provides basic repository methods for operations with instances of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.IAggregateRepository`1.Save``1(``0,System.Nullable{System.Int32})">
            <summary>
            Save and persist the provided <paramref name="aggregate"/>, optionally providing the version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is expected to be at.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregate">The <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to save and persist.</param>
            <param name="expectedVersion">The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is expected to be at.</param>
        </member>
        <member name="M:Cqrs.Domain.IAggregateRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <typeparamref name="TAggregateRoot"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to retrieve.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Cache.CacheRepository`1.#ctor(Cqrs.Domain.IAggregateRepository{`0},Cqrs.Events.IEventStore{`0})">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Cache.CacheRepository`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Cache.CacheRepository`1.Save``1(``0,System.Nullable{System.Int32})">
            <summary>
            Locks the cache, adds the provided <paramref name="aggregate"/> to the cache if not already in it, then calls <see cref="M:Cqrs.Domain.IAggregateRepository`1.Save``1(``0,System.Nullable{System.Int32})"/> on <see cref="P:Cqrs.Cache.CacheRepository`1.Repository"/>.
            In the event of an <see cref="T:System.Exception"/> the <paramref name="aggregate"/> is always ejected out of the <see cref="P:Cqrs.Cache.CacheRepository`1.Cache"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregate">The <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to save and persist.</param>
            <param name="expectedVersion">The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is expected to be at.</param>
        </member>
        <member name="M:Cqrs.Cache.CacheRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Locks the cache, checks if the aggregate is tracked in the <see cref="P:Cqrs.Cache.CacheRepository`1.Cache"/>, if it is
            retrieves the aggregate from the <see cref="P:Cqrs.Cache.CacheRepository`1.Cache"/> and then uses either the provided <paramref name="events"/> or makes a call <see cref="M:Cqrs.Events.IEventStore`1.Get(System.Type,System.Guid,System.Boolean,System.Int32)"/> on the <see cref="P:Cqrs.Cache.CacheRepository`1.EventStore"/>
            and rehydrates the cached aggregate with any new events from it's cached version.
            If the aggregate is not in the <see cref="P:Cqrs.Cache.CacheRepository`1.Cache"/>
            <see cref="M:Cqrs.Domain.IAggregateRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})"/> is called on the <see cref="P:Cqrs.Cache.CacheRepository`1.Repository"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The ID of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to get.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="P:Cqrs.Cache.CacheRepository`1.Repository">
            <summary>
            Sets or set the <see cref="T:Cqrs.Domain.IAggregateRepository`1"/> that will be used, and cached over.
            </summary>
        </member>
        <member name="P:Cqrs.Cache.CacheRepository`1.EventStore">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Events.IEventStore`1"/> used to retrieve events from when a cache hit occurs.
            </summary>
        </member>
        <member name="P:Cqrs.Cache.CacheRepository`1.Cache">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Caching.MemoryCache"/> used.
            </summary>
        </member>
        <member name="T:Cqrs.Commands.DtoCommand`2">
            <summary>
            A <see cref="T:Cqrs.Commands.ICommand`1"/> for <see cref="T:Cqrs.Domain.IDto"/> objects
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
            <typeparam name="TDto">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IDto"/> this command targets.</typeparam>
        </member>
        <member name="T:Cqrs.Commands.ICommand`1">
            <summary>
            People request changes to the domain by sending <see cref="T:Cqrs.Commands.ICommand`1"/>s. They are named with a verb in the imperative mood plus and may include the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> type, for example ConfirmOrder. Unlike an <see cref="T:Cqrs.Events.IEvent`1"/>, a <see cref="T:Cqrs.Commands.ICommand`1"/> is not a statement of fact; it's only a request, and thus may be refused. (A typical way to convey refusal is to raise a specifically typed <see cref="T:Cqrs.Events.IEvent`1"/> stating the <see cref="T:Cqrs.Commands.ICommand`1"/> didn't happen for a specific reason).
            </summary>
            <example>
            public class ConfirmOrder
            {
            	public Guid OrderRsn;
            }
            </example>
            <remarks>
            What does a <see cref="T:Cqrs.Commands.ICommand`1"/> or an <see cref="T:Cqrs.Events.IEvent`1"/> look like?
            
            An <see cref="T:Cqrs.Commands.ICommand`1"/> or <see cref="T:Cqrs.Events.IEvent`1"/> is simply a data structure that contain data for reading, and no behavior. We call such structures "Data Transfer Objects" (DTOs). The name indicates the purpose. In many languages they are represented as classes, but they are not true classes in the real OO sense.
            
            
            What is the difference between a <see cref="T:Cqrs.Commands.ICommand`1"/> and an <see cref="T:Cqrs.Events.IEvent`1"/>?
            
            Their intent.
            
            
            What is immutability? Why is a <see cref="T:Cqrs.Commands.ICommand`1"/> or <see cref="T:Cqrs.Events.IEvent`1"/> immutable?
            
            For the purpose of this question, immutability is not having any setters, or other methods which change internal state. The <see cref="T:System.String"/> type in is a familiar example; you never actually change an existing <see cref="T:System.String"/> value, you just create new <see cref="T:System.String"/> values based on old ones.
            
            An <see cref="T:Cqrs.Commands.ICommand`1"/> is immutable because their expected usage is to be sent directly to the domain model side for processing. They do not need to change during their projected lifetime in traveling from client to server.
            Sometimes however business logic dictates that a decision may be made to construct a <see cref="T:Cqrs.Commands.ICommand`1"/> and local variables should be used.
            
            An <see cref="T:Cqrs.Events.IEvent`1"/> is immutable because they represent domain actions that took place in the past. Unless you're Marty McFly, you can't change the past, and sometimes not even then.
            
            
            What is command upgrading?
            
            Upgrading an <see cref="T:Cqrs.Commands.ICommand`1"/> becomes necessary when new requirements cause an existing <see cref="T:Cqrs.Commands.ICommand`1"/> not to be sufficient. Maybe a new field needs to be added, for example, or maybe an existing field should really have been split into several different ones.
            
            
            How do I upgrade my <see cref="T:Cqrs.Commands.ICommand`1"/>s?
            
            How you do the upgrade depends how much control you have over your clients. If you can deploy your client updates and server updates together, just change things in both and deploy the updates. Job done. If not, it's usually best to have the updated <see cref="T:Cqrs.Commands.ICommand`1"/> be a new type and have the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> accept both for a while.
            
            
            Could you give an example of names of some versioned <see cref="T:Cqrs.Commands.ICommand`1"/>?
            
            Sure.
            
            UploadFile
            UploadFile_v2
            UploadFile_v3
            
            It's just a convention, but a sane one.
            ********************************************
            Also see http://cqrs.nu/Faq/commands-and-events.
            </remarks>
        </member>
        <member name="T:Cqrs.Messages.IMessageWithAuthenticationToken`1">
            <summary>
            A <see cref="T:Cqrs.Messages.IMessage"/> with a authentication information.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Messages.IMessage">
            <summary>
            A message such as an event or command.
            </summary>
        </member>
        <member name="P:Cqrs.Messages.IMessage.CorrelationId">
            <summary>
            An identifier used to group together several <see cref="T:Cqrs.Messages.IMessage"/>. Any <see cref="T:Cqrs.Messages.IMessage"/> with the same <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/> were triggered by the same initiating request.
            </summary>
        </member>
        <member name="P:Cqrs.Messages.IMessage.OriginatingFramework">
            <summary>
            The originating framework this message was sent from.
            </summary>
        </member>
        <member name="P:Cqrs.Messages.IMessage.Frameworks">
            <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage"/> has been delivered to/sent via already.
            </summary>
        </member>
        <member name="P:Cqrs.Messages.IMessageWithAuthenticationToken`1.AuthenticationToken">
            <summary>
            The <typeparamref name="TAuthenticationToken"/> of the entity that triggered the event to be raised.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.ICommand`1.Id">
            <summary>
            The identifier of the command itself.
            In some cases this may be the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> this command targets.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.ICommand`1.ExpectedVersion">
            <summary>
            The expected version number the targeted <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> is expected to be.
            </summary>
        </member>
        <member name="M:Cqrs.Commands.DtoCommand`2.#ctor(System.Guid,`1,`1)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Commands.DtoCommand`2"/>
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.Original">
            <summary>
            Gets or sets the original version of the <typeparamref name="TDto"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.New">
            <summary>
            Gets or sets the new version of the <typeparamref name="TDto"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.Id">
            <summary>
            The identifier of the command itself.
            In some cases this may be the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> this command targets.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.ExpectedVersion">
            <summary>
            The expected version number the targeted <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> is expected to be.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.AuthenticationToken">
            <summary>
            The <typeparamref name="TAuthenticationToken"/> of the entity that triggered the event to be raised.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.CorrelationId">
            <summary>
            An identifier used to group together several <see cref="T:Cqrs.Messages.IMessage"/>. Any <see cref="T:Cqrs.Messages.IMessage"/> with the same <see cref="P:Cqrs.Commands.DtoCommand`2.CorrelationId"/> were triggered by the same initiating request.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.OriginatingFramework">
            <summary>
            The originating framework this message was sent from.
            </summary>
        </member>
        <member name="P:Cqrs.Commands.DtoCommand`2.Frameworks">
            <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage"/> has been delivered to/sent via already.
            </summary>
        </member>
        <member name="T:Cqrs.Commands.DtoCommandHandler`2">
            <summary>
            A <see cref="T:Cqrs.Commands.ICommandHandle"/> for working with <see cref="T:Cqrs.Commands.DtoCommand`2"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
            <typeparam name="TDto">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IDto"/> this command targets.</typeparam>
        </member>
        <member name="T:Cqrs.Commands.ICommandHandler`2">
            <summary>
            An <see cref="T:Cqrs.Commands.ICommandHandler`2"/> receives an <see cref="T:Cqrs.Commands.ICommand`1"/> and brokers a result from the appropriate <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            "A result" is either a successful application of the command, or an exception.
            This is the common sequence of steps an <see cref="T:Cqrs.Commands.ICommandHandler`2"/> might follow:
            
            Validate the <see cref="T:Cqrs.Commands.ICommand`1"/> on its own merits.
            Ask an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to handle the <see cref="T:Cqrs.Commands.ICommand`1"/>.
            If validation is successful, 0..n <see cref="T:Cqrs.Events.IEvent`1"/> artefacts (1 is common) are queued for publishing.
            Attempt to persist the new <see cref="T:Cqrs.Events.IEvent`1"/> artefacts. If there's a concurrency conflict during this step, either give up, or retry things.
            Dispatch the queued <see cref="T:Cqrs.Events.IEvent`1"/> artefacts.
            </summary>
            <remarks>
            Should a <see cref="T:Cqrs.Commands.ICommandHandler`2"/> affect one or several <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>s?
            
            Only one.
            
            
            Do I put logic in <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            Yes. Exactly what logic depends on your factoring.
            The logic for validating the <see cref="T:Cqrs.Commands.ICommand`1"/> on its own merits always gets executed in the <see cref="T:Cqrs.Commands.ICommandHandler`2"/>, although we recommend refactoring these into an <see cref="T:Cqrs.Commands.ICommandValidator`2"/>.
            Provided validation is successful we recommend a more functional factoring, where the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> exists independently of the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> and the next step would be to load the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> and request the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> handle the <see cref="T:Cqrs.Commands.ICommand`1"/> itself.
            The <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> should then have uncommitted <see cref="T:Cqrs.Events.IEvent`1"/> artefacts as a results of asking the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to handle the <see cref="T:Cqrs.Commands.ICommand`1"/>.
            Finally the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> should instruct the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> to <see cref="M:Cqrs.Domain.IUnitOfWork`1.Commit"/> all uncommited <see cref="T:Cqrs.Events.IEvent`1"/> artefacts.
            
            However you have it, the logic boils down to validation and some sequence of steps that lead to the <see cref="T:Cqrs.Commands.ICommand`1"/> becoming an <see cref="T:System.Exception"/> or <see cref="T:Cqrs.Events.IEvent`1"/>(s). If you're tempted to go beyond this, see the rest of the remarks.
            
            
            Can I call a read side (such as a read store, data store or <see cref="T:Cqrs.Domain.IAggregateRepository`1"/>) from my <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            No.
            
            
            Can I do logging, security, or auditing in my <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            Yes. The decorator pattern comes in handy here to separate those concerns neatly.
            
            
            How are conflicts between concurrent <see cref="T:Cqrs.Commands.ICommand`1"/>s handled in the <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            The place where the new <see cref="T:Cqrs.Events.IEvent`1"/> artefacts for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> are persisted is the only place in the system where we need to worry about concurrency conflicts. The <see cref="T:Cqrs.Events.IEventStore`1"/> knows the sequence number of the latest <see cref="T:Cqrs.Events.IEvent`1"/> applied on that <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>, and the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> knows the sequence number of the last <see cref="T:Cqrs.Events.IEvent`1"/> it read. If these numbers do not agree, it means some other thread or process got there first. The <see cref="T:Cqrs.Commands.ICommandHandler`2"/> can then load up the events again and make a new attempt.
            
            
            Should I do things that have side-effects in the outside world (such as sending email) directly in a <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            No, since a concurrency conflict will mean the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> logic will be run again. Do such things in an Apply <see cref="T:Cqrs.Events.IEvent`1"/> method in an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            ********************************************
            Also see http://cqrs.nu/Faq/command-handlers.
            </remarks>
        </member>
        <member name="T:Cqrs.Messages.IMessageHandler`1">
            <summary>
            Responds to or "Handles" a <see cref="T:Cqrs.Messages.IMessage"/>.
            </summary>
            <typeparam name="TMessage">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/>.</typeparam>
        </member>
        <member name="T:Cqrs.Messages.IHandler">
            <summary>
            Responds to or "Handles" things.
            </summary>
        </member>
        <member name="M:Cqrs.Messages.IMessageHandler`1.Handle(`0)">
            <summary>
            Responds to the provided <paramref name="message"/>.
            </summary>
            <param name="message">The <typeparamref name="TMessage"/> to respond to or "handle"</param>
        </member>
        <member name="T:Cqrs.Commands.ICommandHandle">
            <summary>
            An <see cref="T:Cqrs.Commands.ICommandHandler`2"/> receives an <see cref="T:Cqrs.Commands.ICommand`1"/> and brokers a result from the appropriate <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            "A result" is either a successful application of the command, or an exception.
            This is the common sequence of steps an <see cref="T:Cqrs.Commands.ICommandHandler`2"/> might follow:
            
            Validate the <see cref="T:Cqrs.Commands.ICommand`1"/> on its own merits.
            Ask an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to handle the <see cref="T:Cqrs.Commands.ICommand`1"/>.
            If validation is successful, 0..n <see cref="T:Cqrs.Events.IEvent`1"/> artefacts (1 is common) are queued for publishing.
            Attempt to persist the new <see cref="T:Cqrs.Events.IEvent`1"/> artefacts. If there's a concurrency conflict during this step, either give up, or retry things.
            Dispatch the queued <see cref="T:Cqrs.Events.IEvent`1"/> artefacts.
            </summary>
            <remarks>
            Should a <see cref="T:Cqrs.Commands.ICommandHandler`2"/> affect one or several <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>s?
            
            Only one.
            
            
            Do I put logic in <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            Yes. Exactly what logic depends on your factoring.
            The logic for validating the <see cref="T:Cqrs.Commands.ICommand`1"/> on its own merits always gets executed in the <see cref="T:Cqrs.Commands.ICommandHandler`2"/>, although we recommend refactoring these into an <see cref="T:Cqrs.Commands.ICommandValidator`2"/>.
            Provided validation is successful we recommend a more functional factoring, where the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> exists independently of the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> and the next step would be to load the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> and request the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> handle the <see cref="T:Cqrs.Commands.ICommand`1"/> itself.
            The <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> should then have uncommitted <see cref="T:Cqrs.Events.IEvent`1"/> artefacts as a results of asking the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to handle the <see cref="T:Cqrs.Commands.ICommand`1"/>.
            Finally the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> should instruct the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> to <see cref="M:Cqrs.Domain.IUnitOfWork`1.Commit"/> all uncommited <see cref="T:Cqrs.Events.IEvent`1"/> artefacts.
            
            However you have it, the logic boils down to validation and some sequence of steps that lead to the <see cref="T:Cqrs.Commands.ICommand`1"/> becoming an <see cref="T:System.Exception"/> or <see cref="T:Cqrs.Events.IEvent`1"/>(s). If you're tempted to go beyond this, see the rest of the remarks.
            
            
            Can I call a read side (such as a read store, data store or <see cref="T:Cqrs.Domain.IAggregateRepository`1"/>) from my <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            No.
            
            
            Can I do logging, security, or auditing in my <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            Yes. The decorator pattern comes in handy here to separate those concerns neatly.
            
            
            How are conflicts between concurrent <see cref="T:Cqrs.Commands.ICommand`1"/>s handled in the <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            The place where the new <see cref="T:Cqrs.Events.IEvent`1"/> artefacts for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> are persisted is the only place in the system where we need to worry about concurrency conflicts. The <see cref="T:Cqrs.Events.IEventStore`1"/> knows the sequence number of the latest <see cref="T:Cqrs.Events.IEvent`1"/> applied on that <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>, and the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> knows the sequence number of the last <see cref="T:Cqrs.Events.IEvent`1"/> it read. If these numbers do not agree, it means some other thread or process got there first. The <see cref="T:Cqrs.Commands.ICommandHandler`2"/> can then load up the events again and make a new attempt.
            
            
            Should I do things that have side-effects in the outside world (such as sending email) directly in a <see cref="T:Cqrs.Commands.ICommandHandler`2"/>?
            
            No, since a concurrency conflict will mean the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> logic will be run again. Do such things in an Apply <see cref="T:Cqrs.Events.IEvent`1"/> method in an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            ********************************************
            Also see http://cqrs.nu/Faq/command-handlers.
            </remarks>
        </member>
        <member name="M:Cqrs.Commands.DtoCommandHandler`2.#ctor(Cqrs.Domain.IUnitOfWork{`0})">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Commands.DtoCommandHandler`2"/>
            </summary>
        </member>
        <member name="M:Cqrs.Commands.DtoCommandHandler`2.Handle(Cqrs.Commands.DtoCommand{`0,`1})">
            <summary>
            Responds to the provided <paramref name="message"/>.
            </summary>
            <param name="message">The <see cref="T:Cqrs.Commands.DtoCommand`2"/> to respond to or "handle"</param>
        </member>
        <member name="T:Cqrs.Commands.ICommandPublisher`1">
            <summary>
            Publishes an <see cref="T:Cqrs.Commands.ICommand`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Commands.ICommandPublisher`1.Publish``1(``0)">
            <summary>
            Publishes the provided <paramref name="command"/> on the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Commands.ICommandPublisher`1.Publish``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Publishes the provided <paramref name="commands"/> on the command bus.
            </summary>
        </member>
        <member name="T:Cqrs.Commands.IPublishAndWaitCommandPublisher`1">
            <summary>
            Publishes an <see cref="T:Cqrs.Commands.ICommand`1"/>
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Commands.IPublishAndWaitCommandPublisher`1.PublishAndWait``2(``0,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.IPublishAndWaitCommandPublisher`1.PublishAndWait``2(``0,System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.IPublishAndWaitCommandPublisher`1.PublishAndWait``2(``0,System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.IPublishAndWaitCommandPublisher`1.PublishAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits until the specified condition is satisfied an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.IPublishAndWaitCommandPublisher`1.PublishAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.IPublishAndWaitCommandPublisher`1.PublishAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="T:Cqrs.Commands.ISendAndWaitCommandSender`1">
            <summary>
            Sends an <see cref="T:Cqrs.Commands.ICommand`1"/>
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Commands.ICommandSender`1">
            <summary>
            Sends an <see cref="T:Cqrs.Commands.ICommand`1"/>
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Commands.ICommandSender`1.Send``1(``0)">
            <summary>
            Publishes the provided <paramref name="command"/> on the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Commands.ICommandSender`1.Send``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Publishes the provided <paramref name="commands"/> on the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits until the specified condition is satisfied an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="T:Cqrs.Commands.ICommandValidator`2">
            <summary>
            Validates an <see cref="T:Cqrs.Commands.ICommand`1"/> on its own merits.
            </summary>
        </member>
        <member name="M:Cqrs.Commands.ICommandValidator`2.IsCommandValid(`1)">
            <summary>
            Validates the provided <param name="command" /> on its own merits.
            </summary>
        </member>
        <member name="T:Cqrs.Exceptions.MultipleCommandHandlersRegisteredException">
            <summary>
            The <see cref="T:System.Exception"/> that is thrown when more than one <see cref="T:Cqrs.Commands.ICommandHandler`2"/> if found for a given <see cref="T:Cqrs.Commands.ICommand`1"/> that only expects one.
            </summary>
        </member>
        <member name="M:Cqrs.Exceptions.MultipleCommandHandlersRegisteredException.#ctor(System.Type)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Exceptions.MultipleCommandHandlersRegisteredException"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Commands.ICommand`1"/> that expected only one <see cref="T:Cqrs.Commands.ICommandHandler`2"/>.</param>
        </member>
        <member name="M:Cqrs.Exceptions.MultipleCommandHandlersRegisteredException.#ctor(System.String)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Exceptions.MultipleCommandHandlersRegisteredException"/> with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:Cqrs.Exceptions.NoHandlerRegisteredException">
            <summary>
            The <see cref="T:System.Exception"/> that is thrown when no <see cref="T:Cqrs.Messages.IHandler"/> if found for a given <see cref="T:Cqrs.Messages.IMessage"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Exceptions.NoHandlerRegisteredException.#ctor(System.Type)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Exceptions.NoHandlerRegisteredException"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IMessage"/> that expected a <see cref="T:Cqrs.Messages.IHandler"/>.</param>
        </member>
        <member name="M:Cqrs.Exceptions.NoHandlerRegisteredException.#ctor(System.String)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Exceptions.NoHandlerRegisteredException"/> with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:Cqrs.Exceptions.NoCommandHandlerRegisteredException">
            <summary>
            The <see cref="T:System.Exception"/> that is thrown when no <see cref="T:Cqrs.Commands.ICommandHandler`2"/> if found for a given <see cref="T:Cqrs.Commands.ICommand`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Exceptions.NoCommandHandlerRegisteredException.#ctor(System.Type)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Exceptions.NoCommandHandlerRegisteredException"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Commands.ICommand`1"/> that expected an <see cref="T:Cqrs.Commands.ICommandHandler`2"/>.</param>
        </member>
        <member name="M:Cqrs.Exceptions.NoCommandHandlerRegisteredException.#ctor(System.String)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Exceptions.NoCommandHandlerRegisteredException"/> with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:Cqrs.Configuration.ConfigurationExtensions">
            <summary>
            A collection of extension methods for <see cref="T:Cqrs.Configuration.IConfigurationManager"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.ConfigurationExtensions.CreateTelemetryHelper(Cqrs.Configuration.IConfigurationManager,System.String,Cqrs.Configuration.IDependencyResolver)">
            <summary>
            Creates an instance of <see cref="T:cdmdotnet.Logging.ITelemetryHelper"/> if the value for <paramref name="configurationKey"/> is true.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.ConfigurationExtensions.CreateTelemetryHelper(Cqrs.Configuration.IConfigurationManager,System.String,cdmdotnet.Logging.ICorrelationIdHelper)">
            <summary>
            Creates an instance of <see cref="T:cdmdotnet.Logging.ITelemetryHelper"/> if the value for <paramref name="configurationKey"/> is true.
            </summary>
        </member>
        <member name="T:Cqrs.Configuration.ConfigurationManager">
            <summary>
            Provides access to configuration settings from the app settings of an app.config or web.config... i.e. <see cref="P:System.Configuration.ConfigurationManager.AppSettings"/>
            </summary>
        </member>
        <member name="T:Cqrs.Configuration.IConfigurationManager">
            <summary>
            Provides access to configuration settings.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.IConfigurationManager.GetSetting(System.String)">
            <summary>
            Read the setting named <paramref name="key"/>.
            </summary>
            <param name="key">The key (or name) of the setting to read.</param>
        </member>
        <member name="M:Cqrs.Configuration.IConfigurationManager.TryGetSetting(System.String,System.String@)">
            <summary>
            Read the setting named <paramref name="key"/>.
            </summary>
            <param name="key">The key (or name) of the setting to read.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
            <returns>true if the an element with the specified key exists; otherwise, false.</returns>
        </member>
        <member name="M:Cqrs.Configuration.IConfigurationManager.TryGetSetting(System.String,System.Boolean@)">
            <summary>
            Read the setting named <paramref name="key"/>.
            </summary>
            <param name="key">The key (or name) of the setting to read.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
            <returns>true if the an element with the specified key exists; otherwise, false.</returns>
        </member>
        <member name="M:Cqrs.Configuration.ConfigurationManager.GetSetting(System.String)">
            <summary>
            Read the setting named <paramref name="key"/>.
            </summary>
            <param name="key">The key (or name) of the setting to read.</param>
        </member>
        <member name="M:Cqrs.Configuration.ConfigurationManager.TryGetSetting(System.String,System.String@)">
            <summary>
            Read the setting named <paramref name="key"/>.
            </summary>
            <param name="key">The key (or name) of the setting to read.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
            <returns>true if the an element with the specified key exists; otherwise, false.</returns>
        </member>
        <member name="M:Cqrs.Configuration.ConfigurationManager.TryGetSetting(System.String,System.Boolean@)">
            <summary>
            Read the setting named <paramref name="key"/>.
            </summary>
            <param name="key">The key (or name) of the setting to read.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
            <returns>true if the an element with the specified key exists; otherwise, false.</returns>
        </member>
        <member name="T:Cqrs.Configuration.DependencyResolver">
            <summary>
            Provides an ability to resolve instances of objects.
            </summary>
        </member>
        <member name="T:Cqrs.Configuration.IDependencyResolver">
            <summary>
            Provides an ability to resolve instances of objects.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.IDependencyResolver.Resolve``1">
            <summary>
            Resolves a single instance for the specified <typeparamref name="T"/>.
            Different implementations may return the first or last instance found or may return an exception.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of object you want to resolve.</typeparam>
            <returns>An instance of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Cqrs.Configuration.IDependencyResolver.Resolve(System.Type)">
            <summary>
            Resolves a single instance for the specified <paramref name="type"/>.
            Different implementations may return the first or last instance found or may return an exception.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of object you want to resolve.</param>
            <returns>An instance of type <paramref name="type"/>.</returns>
        </member>
        <member name="M:Cqrs.Configuration.DependencyResolver.Resolve``1">
            <summary>
            Resolves a single instance for the specified <typeparamref name="T"/>.
            Different implementations may return the first or last instance found or may return an exception.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of object you want to resolve.</typeparam>
            <returns>An instance of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Cqrs.Configuration.DependencyResolver.Resolve(System.Type)">
            <summary>
            Resolves a single instance for the specified <paramref name="type"/>.
            Different implementations may return the first or last instance found or may return an exception.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of object you want to resolve.</param>
            <returns>An instance of type <paramref name="type"/>.</returns>
        </member>
        <member name="P:Cqrs.Configuration.DependencyResolver.Current">
            <summary>
            The current instance of the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Configuration.HandlerDelegate">
            <summary>
            Information about a <see cref="T:Cqrs.Messages.IHandler"/> delegate.
            </summary>
        </member>
        <member name="T:Cqrs.Configuration.ITelemetryHelperExtensions">
            <summary>
            A collection of extension methods for <see cref="T:cdmdotnet.Logging.ITelemetryHelper"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.ITelemetryHelperExtensions.TrackRequest``1(cdmdotnet.Logging.ITelemetryHelper,System.String,``0,System.DateTimeOffset,System.TimeSpan,System.String,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Send information about a request handled by the application.
            </summary>
            <param name="telemetryHelper">The <see cref="T:cdmdotnet.Logging.ITelemetryHelper"/> being extended.s</param>
            <param name="name">The request name.</param>
            <param name="token">The token with user identifiable information.</param>
            <param name="startTime">The time when the page was requested.</param>
            <param name="duration">The time taken by the application to handle the request.</param>
            <param name="responseCode">The response status code.</param>
            <param name="wasSuccessfull">True if the request was handled successfully by the application.</param>
            <param name="properties">Named string values you can use to search and classify events.</param>
        </member>
        <member name="M:Cqrs.Configuration.ITelemetryHelperExtensions.TrackRequest(cdmdotnet.Logging.ITelemetryHelper,System.String,System.Nullable{System.Guid},System.DateTimeOffset,System.TimeSpan,System.String,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Send information about a request handled by the application.
            </summary>
            <param name="telemetryHelper">The <see cref="T:cdmdotnet.Logging.ITelemetryHelper"/> being extended.s</param>
            <param name="name">The request name.</param>
            <param name="token">The token with user identifiable information.</param>
            <param name="startTime">The time when the page was requested.</param>
            <param name="duration">The time taken by the application to handle the request.</param>
            <param name="responseCode">The response status code.</param>
            <param name="wasSuccessfull">True if the request was handled successfully by the application.</param>
            <param name="properties">Named string values you can use to search and classify events.</param>
        </member>
        <member name="M:Cqrs.Configuration.ITelemetryHelperExtensions.TrackRequest(cdmdotnet.Logging.ITelemetryHelper,System.String,System.Nullable{System.Int32},System.DateTimeOffset,System.TimeSpan,System.String,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Send information about a request handled by the application.
            </summary>
            <param name="telemetryHelper">The <see cref="T:cdmdotnet.Logging.ITelemetryHelper"/> being extended.s</param>
            <param name="name">The request name.</param>
            <param name="token">The token with user identifiable information.</param>
            <param name="startTime">The time when the page was requested.</param>
            <param name="duration">The time taken by the application to handle the request.</param>
            <param name="responseCode">The response status code.</param>
            <param name="wasSuccessfull">True if the request was handled successfully by the application.</param>
            <param name="properties">Named string values you can use to search and classify events.</param>
        </member>
        <member name="M:Cqrs.Configuration.ITelemetryHelperExtensions.TrackRequest(cdmdotnet.Logging.ITelemetryHelper,System.String,System.String,System.DateTimeOffset,System.TimeSpan,System.String,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Send information about a request handled by the application.
            </summary>
            <param name="telemetryHelper">The <see cref="T:cdmdotnet.Logging.ITelemetryHelper"/> being extended.s</param>
            <param name="name">The request name.</param>
            <param name="token">The token with user identifiable information.</param>
            <param name="startTime">The time when the page was requested.</param>
            <param name="duration">The time taken by the application to handle the request.</param>
            <param name="responseCode">The response status code.</param>
            <param name="wasSuccessfull">True if the request was handled successfully by the application.</param>
            <param name="properties">Named string values you can use to search and classify events.</param>
        </member>
        <member name="T:Cqrs.DataStores.SqlDataStoreExtension">
            <summary>
            A collection of extension methods for <see cref="T:System.Data.Linq.Table`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStoreExtension.Truncate``1(System.Data.Linq.Table{``0})">
            <summary>
            Calls the TRUNCATE SQL command on the <see cref="T:System.Data.Linq.Table`1"/>.
            </summary>
            <typeparam name="TEntity">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Entities.IEntity"/> to truncate all data of.</typeparam>
            <param name="table">The <see cref="T:System.Data.Linq.Table`1"/> to truncate all data of.</param>
        </member>
        <member name="T:Cqrs.DataStores.IDataStore`1">
            <summary>
            A data store capable of being queried and modified.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.IDataStore`1.Add(`0)">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.IDataStore`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.IDataStore`1.Remove(`0)">
            <summary>
            Will mark the <paramref name="data"/> as logically (or soft) deleted by setting <see cref="P:Cqrs.Entities.Entity.IsLogicallyDeleted"/> to true in the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.IDataStore`1.Destroy(`0)">
            <summary>
            Remove the provided <paramref name="data"/> (normally by <see cref="P:Cqrs.Entities.IEntity.Rsn"/>) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.IDataStore`1.RemoveAll">
            <summary>
            Remove all contents (normally by use of a truncate operation) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.IDataStore`1.Update(`0)">
            <summary>
            Update the provided <paramref name="data"/> in the data store and persist the change.
            </summary>
        </member>
        <member name="T:Cqrs.DataStores.InProcessDataStore`1">
            <summary>
            A <see cref="T:Cqrs.DataStores.IDataStore`1"/> using an <see cref="P:Cqrs.DataStores.InProcessDataStore`1.InMemoryDatabase"/>.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.#ctor">
            <summary>
            Instantiates a new instance of the <see cref="T:Cqrs.DataStores.InProcessDataStore`1"/> class
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.Add(`0)">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.Remove(`0)">
            <summary>
            Will mark the <paramref name="data"/> as logically (or soft) deleted by setting <see cref="P:Cqrs.Entities.Entity.IsLogicallyDeleted"/> to true in the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.Destroy(`0)">
            <summary>
            Remove the provided <paramref name="data"/> (normally by <see cref="P:Cqrs.Entities.IEntity.Rsn"/>) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.RemoveAll">
            <summary>
            Remove all contents (normally by use of a truncate operation) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.InProcessDataStore`1.Update(`0)">
            <summary>
            Update the provided <paramref name="data"/> in the data store and persist the change.
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.InProcessDataStore`1.Expression">
            <summary>
            Gets the expression tree that is associated with the instance of <see cref="T:System.Linq.IQueryable"/>.
            </summary>
            <returns>
            The <see cref="T:System.Linq.Expressions.Expression"/> that is associated with this instance of <see cref="T:System.Linq.IQueryable"/>.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.InProcessDataStore`1.ElementType">
            <summary>
            Gets the type of the element(s) that are returned when the expression tree associated with this instance of <see cref="T:System.Linq.IQueryable"/> is executed.
            </summary>
            <returns>
            A <see cref="T:System.Type"/> that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.InProcessDataStore`1.Provider">
            <summary>
            Gets the singleResultQuery provider that is associated with this data source.
            </summary>
            <returns>
            The <see cref="T:System.Linq.IQueryProvider"/> that is associated with this data source.
            </returns>
        </member>
        <member name="T:Cqrs.DataStores.SqlDataStore`1">
            <summary>
            A <see cref="T:Cqrs.DataStores.IDataStore`1"/> using simplified SQL.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.#ctor(Cqrs.Configuration.IConfigurationManager,cdmdotnet.Logging.ILogger)">
            <summary>
            Instantiates a new instance of the <see cref="T:Cqrs.DataStores.SqlDataStore`1"/> class
            </summary>
        </member>
        <member name="F:Cqrs.DataStores.SqlDataStore`1._writeableConnections">
            <summary>
            Gets or sets the list of writeable DataContexts for data mirroring
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.CreateDbDataContext">
            <summary>
            Locate the connection settings and create a <see cref="T:System.Data.Linq.DataContext"/>.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.GetWriteableConnectionStrings">
            <summary>
            Locate the connection settings for persisting data.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Add(`0)">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the provided <paramref name="data"/> to the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Remove(`0)">
            <summary>
            Will mark the <paramref name="data"/> as logically (or soft) deleted by setting <see cref="P:Cqrs.Entities.Entity.IsLogicallyDeleted"/> to true in the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Destroy(`0)">
            <summary>
            Remove the provided <paramref name="data"/> (normally by <see cref="P:Cqrs.Entities.IEntity.Rsn"/>) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.RemoveAll">
            <summary>
            Remove all contents (normally by use of a truncate operation) from the data store and persist the change.
            </summary>
        </member>
        <member name="M:Cqrs.DataStores.SqlDataStore`1.Update(`0)">
            <summary>
            Update the provided <paramref name="data"/> in the data store and persist the change.
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.ConfigurationManager">
            <summary />
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.DbDataContext">
            <summary>
            Gets or sets the DataContext.
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.WriteableConnectionStrings">
            <summary>
            Gets or sets the list of writeable connection strings for data mirroring
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.WriteableConnections">
            <summary>
            Gets or sets the list of writeable DataContexts for data mirroring
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.Table">
            <summary>
            Gets or sets the readable Table
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.Logger">
            <summary>
            Gets or sets the Logger
            </summary>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.Expression">
            <summary>
            Gets the expression tree that is associated with the instance of <see cref="T:System.Linq.IQueryable"/>.
            </summary>
            <returns>
            The <see cref="T:System.Linq.Expressions.Expression"/> that is associated with this instance of <see cref="T:System.Linq.IQueryable"/>.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.ElementType">
            <summary>
            Gets the type of the element(s) that are returned when the expression tree associated with this instance of <see cref="T:System.Linq.IQueryable"/> is executed.
            </summary>
            <returns>
            A <see cref="T:System.Type"/> that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.
            </returns>
        </member>
        <member name="P:Cqrs.DataStores.SqlDataStore`1.Provider">
            <summary>
            Gets the query provider that is associated with this data source.
            </summary>
            <returns>
            The <see cref="T:System.Linq.IQueryProvider"/> that is associated with this data source.
            </returns>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.EntityNotFoundException`1">
            <summary>
            The <see cref="T:Cqrs.Entities.IEntity"/> requested was not found.
            </summary>
            <typeparam name="TEntity">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Entities.IEntity"/> that wasn't found</typeparam>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.EntityNotFoundException`1.#ctor(System.Guid)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.EntityNotFoundException`1"/> with the provided identifier of the <see cref="T:Cqrs.Entities.IEntity"/> that wasn't found.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Entities.IEntity"/> that wasn't found.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.EntityNotFoundException`1.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Entities.IEntity"/> that wasn't found.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.EntityNotFoundException`1.EntityType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Entities.IEntity"/> that wasn't found.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.DuplicateSagaEventException`2">
            <summary>
            The <see cref="T:Cqrs.Events.IEventStore`1"/> gave more than one event.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/> that wasn't found.</typeparam>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.DuplicateSagaEventException`2.#ctor(System.Guid,System.Int32)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.DuplicateSagaEventException`2"/> with the provided identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> that had duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see>.
            and the <paramref name="version"/> that had more than one <see cref="T:Cqrs.Events.IEvent`1"/> provided.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> that had <see cref="T:Cqrs.Events.IEvent`1">events</see>.</param>
            <param name="version">The version number of the duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see></param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.DuplicateSagaEventException`2.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> that had duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see>..
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.DuplicateSagaEventException`2.SagaType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/> that had duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see>..
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.SagaNotFoundException`2">
            <summary>
            The <see cref="T:Cqrs.Domain.ISaga`1"/> requested was not found.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/> that wasn't found.</typeparam>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.SagaNotFoundException`2.#ctor(System.Guid)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.SagaNotFoundException`2"/> with the provided identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> that wasn't found.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> that wasn't found.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.SagaNotFoundException`2.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> that wasn't found.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.SagaNotFoundException`2.SagaType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/> that wasn't found.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.ISagaRepository`1">
            <summary>
            Provides basic repository methods for operations with instances of <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.ISagaRepository`1.Save``1(``0,System.Nullable{System.Int32})">
            <summary>
            Save and persist the provided <paramref name="saga"/>, optionally providing the version number the <see cref="T:Cqrs.Domain.ISaga`1"/> is expected to be at.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="saga">The <see cref="T:Cqrs.Domain.ISaga`1"/> to save and persist.</param>
            <param name="expectedVersion">The version number the <see cref="T:Cqrs.Domain.ISaga`1"/> is expected to be at.</param>
        </member>
        <member name="M:Cqrs.Domain.ISagaRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.ISagaEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.ISaga`1"/> of type <typeparamref name="TSaga"/>.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="sagaId">The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> to retrieve.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.ISaga`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="T:Cqrs.Domain.ISagaUnitOfWork`1">
            <summary>
            This is a Unit of Work for sagas
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISagaUnitOfWork`1.Add``1(``0)">
            <summary>
            Add an item into the <see cref="T:Cqrs.Domain.ISagaUnitOfWork`1"/> ready to be committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISagaUnitOfWork`1.Get``1(System.Guid,System.Nullable{System.Int32})">
            <summary>
            Get an item from the <see cref="T:Cqrs.Domain.ISagaUnitOfWork`1"/> if it has already been loaded.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISagaUnitOfWork`1.Commit">
            <summary>
            Commit any changed <see cref="T:Cqrs.Domain.Saga`1"/> added to this <see cref="T:Cqrs.Domain.ISagaUnitOfWork`1"/> via <see cref="M:Cqrs.Domain.ISagaUnitOfWork`1.Add``1(``0)"/>
            </summary>
        </member>
        <member name="T:Cqrs.Domain.AggregateRepository`1">
            <summary>
            Provides basic repository methods for operations with instances of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> using an <see cref="T:Cqrs.Events.IEventStore`1"/>
            that also publishes events once saved.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.#ctor(Cqrs.Domain.Factories.IAggregateFactory,Cqrs.Events.IEventStore{`0},Cqrs.Events.IEventPublisher{`0},cdmdotnet.Logging.ICorrelationIdHelper)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.AggregateRepository`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.Save``1(``0,System.Nullable{System.Int32})">
            <summary>
            Save and persist the provided <paramref name="aggregate"/>, optionally providing the version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is expected to be at.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregate">The <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to save and persist.</param>
            <param name="expectedVersion">The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is expected to be at.</param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.PublishEvent(Cqrs.Events.IEvent{`0})">
            <summary>
            Publish the saved <paramref name="event"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <typeparamref name="TAggregateRoot"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to retrieve.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.CreateAggregate``1(System.Guid)">
            <summary>
            Calls <see cref="M:Cqrs.Domain.Factories.IAggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)"/> to get a, <typeparamref name="TAggregateRoot"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="id">The id of the <typeparamref name="TAggregateRoot"/> to create.</param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.LoadAggregate``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Calls <see cref="M:Cqrs.Domain.Factories.IAggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)"/> to get a, <typeparamref name="TAggregateRoot"/> and then calls <see cref="M:Cqrs.Domain.AggregateRepository`1.LoadAggregateHistory``1(``0,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}},System.Boolean)"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="id">The id of the <typeparamref name="TAggregateRoot"/> to create.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.AggregateRepository`1.LoadAggregateHistory``1(``0,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}},System.Boolean)">
            <summary>
            If <paramref name="events"/> is null, loads the events from <see cref="P:Cqrs.Domain.AggregateRepository`1.EventStore"/>, checks for duplicates and then
            rehydrates the <paramref name="aggregate"/> with the events.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregate">The <typeparamref name="TAggregateRoot"/> to rehydrate.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
            <param name="throwExceptionOnNoEvents">If true will throw an instance of <see cref="T:Cqrs.Domain.Exceptions.AggregateNotFoundException`2"/> if no aggregate events or provided or found in the <see cref="P:Cqrs.Domain.AggregateRepository`1.EventStore"/>.</param>
        </member>
        <member name="P:Cqrs.Domain.AggregateRepository`1.EventStore">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Events.IEventStore`1"/> used to store and retrieve events from.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.AggregateRepository`1.Publisher">
            <summary>
            Gets or sets the Publisher used to publish events on once saved into the <see cref="P:Cqrs.Domain.AggregateRepository`1.EventStore"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.AggregateRepository`1.AggregateFactory">
            <summary>
            Gets or set the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.AggregateRepository`1.CorrelationIdHelper">
            <summary>
            Gets or set the <see cref="T:cdmdotnet.Logging.ICorrelationIdHelper"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.SagaEventHandler`2">
            <summary>
            A process manager that you can implement <see cref="T:Cqrs.Events.IEventHandler"/> instances on top of.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.SagaEventHandler`2.#ctor(Cqrs.Configuration.IDependencyResolver,cdmdotnet.Logging.ILogger)">
            <summary>
            A constructor for the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaEventHandler`2.#ctor(Cqrs.Configuration.IDependencyResolver,cdmdotnet.Logging.ILogger,Cqrs.Domain.ISagaUnitOfWork{`0})">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.SagaEventHandler`2"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaEventHandler`2.GetSaga(System.Guid)">
            <summary>
            Gets the <typeparamref name="TSaga"/> from the <see cref="P:Cqrs.Domain.SagaEventHandler`2.SagaUnitOfWork"/>.
            </summary>
            <param name="id">The identifier of the <typeparamref name="TSaga"/> to get.</param>
        </member>
        <member name="P:Cqrs.Domain.SagaEventHandler`2.SagaUnitOfWork">
            <summary>
            Gets or set the <see cref="T:Cqrs.Domain.ISagaUnitOfWork`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.SagaEventHandler`2.DependencyResolver">
            <summary>
            Gets or set the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.SagaEventHandler`2.Logger">
            <summary>
            Gets or set the <see cref="T:cdmdotnet.Logging.ILogger"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.SagaRepository`1">
            <summary>
            Provides basic repository methods for operations with instances of <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.#ctor(Cqrs.Domain.Factories.IAggregateFactory,Cqrs.Events.IEventStore{`0},Cqrs.Events.IEventPublisher{`0},cdmdotnet.Logging.ICorrelationIdHelper)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.SagaRepository`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.Save``1(``0,System.Nullable{System.Int32})">
            <summary>
            Save and persist the provided <paramref name="saga"/>, optionally providing the version number the <see cref="T:Cqrs.Domain.ISaga`1"/> is expected to be at.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="saga">The <see cref="T:Cqrs.Domain.ISaga`1"/> to save and persist.</param>
            <param name="expectedVersion">The version number the <see cref="T:Cqrs.Domain.ISaga`1"/> is expected to be at.</param>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.PublishEvent(Cqrs.Events.ISagaEvent{`0})">
            <summary>
            Publish the saved <paramref name="event"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.ISagaEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.ISaga`1"/> of type <typeparamref name="TSaga"/>.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="sagaId">The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/> to retrieve.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.ISaga`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.CreateSaga``1(System.Guid)">
            <summary>
            Calls <see cref="M:Cqrs.Domain.Factories.IAggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)"/> to get a, <typeparamref name="TSaga"/>.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="id">The id of the <typeparamref name="TSaga"/> to create.</param>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.LoadSaga``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.ISagaEvent{`0}})">
            <summary>
            Calls <see cref="M:Cqrs.Domain.Factories.IAggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)"/> to get a, <typeparamref name="TSaga"/> and then calls <see cref="M:Cqrs.Domain.SagaRepository`1.LoadSagaHistory``1(``0,System.Collections.Generic.IList{Cqrs.Events.ISagaEvent{`0}},System.Boolean)"/>.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="id">The id of the <typeparamref name="TSaga"/> to create.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.ISaga`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Domain.SagaRepository`1.LoadSagaHistory``1(``0,System.Collections.Generic.IList{Cqrs.Events.ISagaEvent{`0}},System.Boolean)">
            <summary>
            If <paramref name="events"/> is null, loads the events from <see cref="P:Cqrs.Domain.SagaRepository`1.EventStore"/>, checks for duplicates and then
            rehydrates the <paramref name="saga"/> with the events.
            </summary>
            <typeparam name="TSaga">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.ISaga`1"/>.</typeparam>
            <param name="saga">The <typeparamref name="TSaga"/> to rehydrate.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.ISaga`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
            <param name="throwExceptionOnNoEvents">If true will throw an instance of <see cref="T:Cqrs.Domain.Exceptions.SagaNotFoundException`2"/> if no aggregate events or provided or found in the <see cref="P:Cqrs.Domain.SagaRepository`1.EventStore"/>.</param>
        </member>
        <member name="P:Cqrs.Domain.SagaRepository`1.EventStore">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Events.IEventStore`1"/> used to store and retrieve events from.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.SagaRepository`1.Publisher">
            <summary>
            Gets or sets the Publisher used to publish events on once saved into the <see cref="P:Cqrs.Domain.SagaRepository`1.EventStore"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.SagaRepository`1.SagaFactory">
            <summary>
            Gets or set the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.SagaRepository`1.CorrelationIdHelper">
            <summary>
            Gets or set the <see cref="T:cdmdotnet.Logging.ICorrelationIdHelper"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.ISaga`1">
            <summary>
            An independent component that reacts to domain <see cref="T:Cqrs.Events.IEvent`1"/> in a cross-<see cref="T:Cqrs.Domain.IAggregateRoot`1"/>, eventually consistent manner. Time can also be a trigger. A <see cref="T:Cqrs.Domain.Saga`1"/> can sometimes be purely reactive, and sometimes represent workflows.
            
            From an implementation perspective, a <see cref="T:Cqrs.Domain.Saga`1"/> is a state machine that is driven forward by incoming <see cref="T:Cqrs.Events.IEvent`1"/> (which may come from many <see cref="T:Cqrs.Domain.AggregateRoot`1"/> or other <see cref="T:Cqrs.Domain.Saga`1"/>). Some states will have side effects, such as sending <see cref="T:Cqrs.Commands.ICommand`1"/>, talking to external web services, or sending emails.
            </summary>
            <remarks>
            Isn't a <see cref="T:Cqrs.Domain.Saga`1"/> just leaked domain logic?
            No.
            A <see cref="T:Cqrs.Domain.Saga`1"/> can doing things that no individual <see cref="T:Cqrs.Domain.AggregateRoot`1"/> can sensibly do. Thus, it's not a logic leak since the logic didn't belong in an <see cref="T:Cqrs.Domain.AggregateRoot`1"/> anyway. Furthermore, we're not breaking encapsulation in any way, since <see cref="T:Cqrs.Domain.Saga`1"/> operate with <see cref="T:Cqrs.Commands.ICommand`1"/> and <see cref="T:Cqrs.Events.IEvent`1"/>, which are part of the public API.
            
            How can I make my <see cref="T:Cqrs.Domain.Saga`1"/> react to an <see cref="T:Cqrs.Events.IEvent`1"/> that did not happen?
            The <see cref="T:Cqrs.Domain.Saga`1"/>, besides reacting to domain <see cref="T:Cqrs.Events.IEvent`1"/>, can be "woken up" by recurrent internal alarms. Implementing such alarms is easy. See cron in Unix, or triggered WebJobs in Azure for examples.
            
            How does the <see cref="T:Cqrs.Domain.Saga`1"/> interact with the write side?
            By sending an <see cref="T:Cqrs.Commands.ICommand`1"/> to it.
            </remarks>
        </member>
        <member name="M:Cqrs.Domain.ISaga`1.GetUncommittedChanges">
            <summary>
            Get all applied changes that haven't yet been committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISaga`1.MarkChangesAsCommitted">
            <summary>
            Mark all applied changes as committed, increment <see cref="P:Cqrs.Domain.ISaga`1.Version"/> and flush the internal collection of changes.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.ISaga`1.LoadFromHistory(System.Collections.Generic.IEnumerable{Cqrs.Events.ISagaEvent{`0}})">
            <summary>
            Apply all the <see cref="T:Cqrs.Events.IEvent`1">events</see> in <paramref name="history"/>
            using event replay to this instance.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.ISaga`1.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.ISaga`1.Version">
            <summary>
            The current version of this <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Saga`1">
            <summary>
            An independent component that reacts to domain <see cref="T:Cqrs.Events.IEvent`1"/> in a cross-<see cref="T:Cqrs.Domain.IAggregateRoot`1"/>, eventually consistent manner. Time can also be a trigger. A <see cref="T:Cqrs.Domain.Saga`1"/> can sometimes be purely reactive, and sometimes represent workflows.
            
            From an implementation perspective, a <see cref="T:Cqrs.Domain.Saga`1"/> is a state machine that is driven forward by incoming <see cref="T:Cqrs.Events.IEvent`1"/> (which may come from many <see cref="T:Cqrs.Domain.AggregateRoot`1"/> or other <see cref="T:Cqrs.Domain.Saga`1"/>). Some states will have side effects, such as sending <see cref="T:Cqrs.Commands.ICommand`1"/>, talking to external web services, or sending emails.
            </summary>
            <remarks>
            Isn't a <see cref="T:Cqrs.Domain.Saga`1"/> just leaked domain logic?
            No.
            A <see cref="T:Cqrs.Domain.Saga`1"/> can doing things that no individual <see cref="T:Cqrs.Domain.AggregateRoot`1"/> can sensibly do. Thus, it's not a logic leak since the logic didn't belong in an <see cref="T:Cqrs.Domain.AggregateRoot`1"/> anyway. Furthermore, we're not breaking encapsulation in any way, since <see cref="T:Cqrs.Domain.Saga`1"/> operate with <see cref="T:Cqrs.Commands.ICommand`1"/> and <see cref="T:Cqrs.Events.IEvent`1"/>, which are part of the public API.
            
            How can I make my <see cref="T:Cqrs.Domain.Saga`1"/> react to an <see cref="T:Cqrs.Events.IEvent`1"/> that did not happen?
            The <see cref="T:Cqrs.Domain.Saga`1"/>, besides reacting to domain <see cref="T:Cqrs.Events.IEvent`1"/>, can be "woken up" by recurrent internal alarms. Implementing such alarms is easy. See cron in Unix, or triggered WebJobs in Azure for examples.
            
            How does the <see cref="T:Cqrs.Domain.Saga`1"/> interact with the write side?
            By sending an <see cref="T:Cqrs.Commands.ICommand`1"/> to it.
            </remarks>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.#ctor">
            <summary>
            A constructor for the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.#ctor(Cqrs.Configuration.IDependencyResolver,cdmdotnet.Logging.ILogger)">
            <summary>
            A constructor for the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.#ctor(Cqrs.Configuration.IDependencyResolver,cdmdotnet.Logging.ILogger,System.Guid)">
            <summary>
            A constructor for the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.GetUncommittedChanges">
            <summary>
            Get all applied changes that haven't yet been committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.MarkChangesAsCommitted">
            <summary>
            Mark all applied changes as committed, increment <see cref="P:Cqrs.Domain.Saga`1.Version"/> and flush the <see cref="P:Cqrs.Domain.Saga`1.Changes">internal collection of changes</see>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.LoadFromHistory(System.Collections.Generic.IEnumerable{Cqrs.Events.ISagaEvent{`0}})">
            <summary>
            Apply all the <see cref="T:Cqrs.Events.IEvent`1">events</see> in <paramref name="history"/>
            using event replay to this instance.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.ApplyChange(Cqrs.Events.ISagaEvent{`0})">
            <summary>
            Call the "Apply" method with a signature matching the provided <paramref name="event"/> without using event replay to this instance.
            </summary>
            <remarks>
            This means a method named "Apply", with return type void and one parameter must exist to be applied.
            If no method exists, nothing is applied
            The parameter type must match exactly the <see cref="T:System.Type"/> of the provided <paramref name="event"/>.
            </remarks>
        </member>
        <member name="M:Cqrs.Domain.Saga`1.ApplyChange(Cqrs.Events.IEvent{`0})">
            <summary>
            Calls the "SetId" method dynamically if the method exists, then calls <see cref="M:Cqrs.Domain.Saga`1.ApplyChange(Cqrs.Events.ISagaEvent{`0})"/>
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Saga`1.Rsn">
            <summary>
            The identifier of this <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Saga`1.Id">
            <summary>
            The identifier of this <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Saga`1.Version">
            <summary>
            The current version of this <see cref="T:Cqrs.Domain.ISaga`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Saga`1.CommandPublisher">
            <summary>
            Gets or set the <see cref="T:Cqrs.Commands.ICommandPublisher`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Saga`1.DependencyResolver">
            <summary>
            Gets or set the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Saga`1.Logger">
            <summary>
            Gets or set the <see cref="T:cdmdotnet.Logging.ILogger"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.AggregateOrEventMissingIdException">
            <summary>
            The <see cref="T:Cqrs.Events.IEvent`1"/> had not <see cref="P:Cqrs.Events.IEvent`1.Id"/> set.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.AggregateOrEventMissingIdException.#ctor(System.Type,System.Type)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.AggregateOrEventMissingIdException"/> with the <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> and <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            The <paramref name="eventType"/> that was trying to be saved on an <paramref name="aggregateType"/>.
            </summary>
            <param name="aggregateType">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that the <see cref="T:Cqrs.Events.IEvent`1"/> was trying to be saved on.</param>
            <param name="eventType">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> that was trying to be saved.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.AggregateOrEventMissingIdException.AggregateType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that the <see cref="T:Cqrs.Events.IEvent`1"/> was trying to be saved on.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.AggregateOrEventMissingIdException.EventType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> that was trying to be saved.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.AggregateRoot`1">
            <summary>
            A larger unit of encapsulation than just a class. Every transaction is scoped to a single aggregate. The lifetimes of the components of an aggregate are bounded by the lifetime of the entire aggregate.
            
            Concretely, an aggregate will handle commands, apply events, and have a state model encapsulated within it that allows it to implement the required command validation, thus upholding the invariants (business rules) of the aggregate.
            </summary>
            <remarks>
            Why is the use of GUID as IDs a good practice?
            
            Because they are (reasonably) globally unique, and can be generated either by the server or by the client.
            </remarks>
        </member>
        <member name="T:Cqrs.Domain.IAggregateRoot`1">
            <summary>
            An <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is a larger unit of encapsulation than just a class. Every transaction is scoped to a single aggregate. The lifetimes of the components of an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> are bounded by the lifetime of the entire <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            
            <para/>Concretely, an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> will handle <see cref="T:Cqrs.Commands.ICommand`1"/>s, apply <see cref="T:Cqrs.Events.IEvent`1"/>s, and have a state model encapsulated within it that allows it to implement the required command validation, thus upholding the invariants (business rules) of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
            <remarks>
            I know <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> are transaction boundaries, but I really need to transactionally update two <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> in the same transaction. What should I do?
            
            <para/>You should re-think the following:
            <para/>* Your <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> boundaries.
            <para/>* The responsibilities of each <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            <para/>* What you can get away with doing in a read side or in a saga.
            <para/>* The actual non-functional requirements of your domain.
            <para/>
            <para/>If you write a solution where two or more <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> are transactionally coupled, you have not understood <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            <para/>
            <para/>
            <para/>Why is the use of <see cref="T:System.Guid"/> as identifiers a good practice?
            <para/>
            <para/>Because they are (reasonably) globally unique, and can be generated either by the server or by the client.
            <para/>
            <para/>
            <para/>What is an Rsn and what is an Id?
            <para/>
            <para/>Because few systems are truely green field and there is usually some existing system to operate with our framework identifies
            <para/>Id properties as <see cref="T:System.Int32"/> typed properties from an external system
            <para/>and Rsn properties as <see cref="T:System.Guid"/> typed properties for internal use.
            <para/>
            <para/>An example might be
            <para/>{
            <para/>	Guid Rsn
            <para/>	string Name
            <para/>	Guid CategoryRsn
            <para/>	int CategoryId
            <para/>}
            <para/>
            <para/>Here the category can be referenced within the CQRS framework by it's Rsn <see cref="T:System.Guid"/> typed identifier, but still has a reference to the external systems <see cref="T:System.Int32"/> typed identifier value.
            <para/>
            <para/>
            <para/>How can I get the Rsn for newly created <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?
            <para/>
            <para/>It's an important insight that the client can generate its own Rsns.
            <para/>
            <para/>If the client generates a <see cref="T:System.Guid"/> and places it in the create-the-aggregate <see cref="T:Cqrs.Commands.ICommand`1"/>, this is a non-issue. Otherwise, you have to listen to the the appropriate the-aggregate-was-created <see cref="T:Cqrs.Events.IEvent`1"/>, where the Rsn will appear be populated.
            <para/>
            <para/>
            <para/>Should I allow references between <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?
            <para/>
            <para/>In the sense of an actual "memory reference", absolutely not.
            <para/>
            <para/>On the write side, an actual memory reference from one <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to another is forbidden and wrong, since <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> by definition are not allowed to reach outside of themselves. (Allowing this would mean an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is no longer a transaction boundary, meaning we can no longer sanely reason about its ability to uphold its invariants; it would also preclude sharding of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.)
            <para/>
            <para/>Referring to another <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> using an identifier is fine. It is useless on the write side (since the identifier must be treated as an opaque value, since <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> can not reach outside of themselves). Read sides may freely use such information, however, to do interesting correlations.
            <para/>
            <para/>
            <para/>How can I validate a <see cref="T:Cqrs.Commands.ICommand`1"/> across a group of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?
            <para/>
            <para/>This is a common reaction to not being able to query across <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> anymore. There are several answers:
            <para/>
            <para/>* Do client-side validation.
            <para/>* Use a read side.
            <para/>* Use a saga.
            <para/>* If those are all completely impractical, then it's time to consider if you got your <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> boundaries correct.
            <para/>
            <para/>
            <para/>How can I guarantee referential integrity across <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?
            <para/>
            <para/>You're still thinking in terms of foreign relations, not <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>. See last question. Also, remember that just because something would be in two tables in a relational design does not in any way suggest it should be two <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>. Designing an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is different.
            <para/>
            <para/>
            <para/>How can I make sure a newly created user has a unique user name?
            <para/>
            <para/>This is a commonly occurring question since we're explicitly not performing cross-aggregate operations on the write side. We do, however, have a number of options:
            <para/>
            <para/>* Create a read-side of already allocated user names. Make the client query the read-side interactively as the user types in a name.
            <para/>* Create a reactive saga to flag down and inactivate accounts that were nevertheless created with a duplicate user name. (Whether by extreme coincidence or maliciously or because of a faulty client.)
            <para/>
            <para/>
            <para/>How can I verify that a customer identifier really exists when I place an order?
            <para/>
            <para/>Assuming customer and order are <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> here, it's clear that the order <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> cannot really validate this, since that would mean reaching out of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            <para/>
            <para/>Checking up on it after the fact, in a saga or just in a read side that records "broken" orders, is one option. After all, the most important thing about an order is actually recording it, and presumably any interesting data about the recipient of the order is being copied into the order <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> (referring to the customer to find the address is bad design; the order was always made to be deliverd to a particular address, whether or not that customer changes their address in the future).
            <para/>
            <para/>Being able to use what data was recorded in this broken order means you've got a chance to rescue it and rectify the situation - which makes a good bit more business sense rather than dropping the order on the floor because a foreign key constraint was violated!
            <para/>
            <para/>
            <para/>How can I update a set of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> with a single <see cref="T:Cqrs.Commands.ICommand`1"/>?
            <para/>
            <para/>A single <see cref="T:Cqrs.Commands.ICommand`1"/> can't act on a set of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>. It just can't.
            <para/>
            <para/>First off, ask yourself whether you really need to update several <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> using just one <see cref="T:Cqrs.Commands.ICommand`1"/>. What in the situation makes this a requirement?
            <para/>
            <para/>However, here's what you could do. Allow a new kind of "bulk command", conceptually containing the command you want to issue, and a set of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> (specified either explicitly or implicitly) that you want to issue it on. The write side isn't powerful enough to make the bulk action, but it's able to create a corresponding "bulk event". A saga captures the event, and issues the <see cref="T:Cqrs.Commands.ICommand`1"/> on each of the specified <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>s. The saga can do rollback or send an email, as appropriate, if some of the <see cref="T:Cqrs.Commands.ICommand`1"/> fail.
            <para/>
            <para/>There are some advantages to this approach: we store the intent of the bulk action in the event store. The saga automates rollback or equivalent.
            <para/>
            <para/>Still, having to resort to this solution is a strong indication that your <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> boundaries are not drawn correctly. You might want to consider changing your <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> boundaries rather than building a saga for this.
            <para/>
            <para/>
            <para/>What is sharding?
            <para/>
            <para/>A way to distribute large amounts of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> on several write-side nodes. We can shard <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> easily because they are completely self-reliant.
            <para/>
            <para/>We can shard <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> easily because they don't have any external references.
            <para/>
            <para/>
            <para/>Can an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> send an <see cref="T:Cqrs.Events.IEvent`1"/> to another <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?
            <para/>
            <para/>No.
            <para/>
            <para/>The factoring of your <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> and <see cref="T:Cqrs.Commands.ICommandHandler`2"/> will typically already make this idea impossible to express in code. But there's a deeper philosophical reason: go back and re-read the first sentence in the answer to "What is an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?". If you manage to circumvent the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> and just push <see cref="T:Cqrs.Events.IEvent`1"/> into another <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> somehow, you will have taken away that <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>'s chance to participate in validation of changes. That's ultimately why we only allow <see cref="T:Cqrs.Events.IEvent`1"/> to be created as a result of <see cref="T:Cqrs.Commands.ICommand`1"/>s validated by a <see cref="T:Cqrs.Commands.ICommandHandler`2"/> on an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            <para/>
            <para/>
            <para/>Can I call a read side from my <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>?
            <para/>
            <para/>No.
            <para/>
            <para/>
            <para/>How do I send e-mail in a CQRS system?
            <para/>
            <para/>In an <see cref="T:Cqrs.Events.IEventHandler`2"/> outside of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>. Do not do it in the <see cref="T:Cqrs.Commands.ICommandHandler`2"/>, as if the <see cref="T:Cqrs.Events.IEvent`1"/> artefacts are not persisted due to losing a race with another <see cref="T:Cqrs.Commands.ICommand`1"/> then the email will have been sent on a false premise.
            <para/>********************************************
            <para/>Also see http://cqrs.nu/Faq/aggregates.
            </remarks>
        </member>
        <member name="M:Cqrs.Domain.IAggregateRoot`1.GetUncommittedChanges">
            <summary>
            Get all applied changes that haven't yet been committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.IAggregateRoot`1.MarkChangesAsCommitted">
            <summary>
            Mark all applied changes as committed, increment <see cref="P:Cqrs.Domain.IAggregateRoot`1.Version"/> and flush the internal collection of changes.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.IAggregateRoot`1.LoadFromHistory(System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}})">
            <summary>
            Apply all the <see cref="T:Cqrs.Events.IEvent`1">events</see> in <paramref name="history"/>
            using event replay to this instance.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.IAggregateRoot`1.Id">
            <summary>
            The identifier of this <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.IAggregateRoot`1.Version">
            <summary>
            The current version of this <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRoot`1.#ctor">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.AggregateRoot`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRoot`1.GetUncommittedChanges">
            <summary>
            Get all applied changes that haven't yet been committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRoot`1.MarkChangesAsCommitted">
            <summary>
            Mark all applied changes as committed, increment <see cref="P:Cqrs.Domain.AggregateRoot`1.Version"/> and flush the <see cref="P:Cqrs.Domain.AggregateRoot`1.Changes">internal collection of changes</see>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRoot`1.LoadFromHistory(System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}})">
            <summary>
            Apply all the <see cref="T:Cqrs.Events.IEvent`1">events</see> in <paramref name="history"/>
            using event replay to this instance.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.AggregateRoot`1.ApplyChange(Cqrs.Events.IEvent{`0})">
            <summary>
            Call the "Apply" method with a signature matching the provided <paramref name="event"/> without using event replay to this instance.
            </summary>
            <remarks>
            This means a method named "Apply", with return type void and one parameter must exist to be applied.
            If no method exists, nothing is applied
            The parameter type must match exactly the <see cref="T:System.Type"/> of the provided <paramref name="event"/>.
            </remarks>
        </member>
        <member name="P:Cqrs.Domain.AggregateRoot`1.Id">
            <summary>
            The identifier of this <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.AggregateRoot`1.Version">
            <summary>
            The current version of this <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.DuplicateCreateCommandException">
            <summary>
            The operation resulted in a duplicate.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.DuplicateCreateCommandException.#ctor(System.String,System.Exception)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.DuplicateCreateCommandException"/> with a specified <paramref name="message">error message</paramref> and a reference to the inner <paramref name="exception"/> that is the cause of this <see cref="T:System.Exception"/>.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="exception">The <see cref="T:System.Exception"/> that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner <see cref="T:System.Exception"/> is specified.</param>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.DuplicateCreateCommandException.#ctor(System.Exception)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.DuplicateCreateCommandException"/> with a reference to the inner <paramref name="exception"/> that is the cause of this <see cref="T:System.Exception"/>.
            </summary>
            <param name="exception">The <see cref="T:System.Exception"/> that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner <see cref="T:System.Exception"/> is specified.</param>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.DuplicateCreateCommandException.#ctor(System.Type,System.Guid,System.Exception)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.DuplicateCreateCommandException"/> with 
            the <paramref name="commandType"/> and <paramref name="commandId"/> that was issued as well as
            a reference to the inner <paramref name="exception"/> that is the cause of this <see cref="T:System.Exception"/>.
            </summary>
            <param name="commandType">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Commands.ICommand`1"/> that was issued.</param>
            <param name="commandId">The <see cref="P:Cqrs.Commands.ICommand`1.Id"/> of the <see cref="T:Cqrs.Commands.ICommand`1"/> that was issued.</param>
            <param name="exception">The <see cref="T:System.Exception"/> that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner <see cref="T:System.Exception"/> is specified.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.DuplicateCreateCommandException.CommandType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Commands.ICommand`1"/> that was issued.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.DuplicateCreateCommandException.CommandId">
            <summary>
            The <see cref="P:Cqrs.Commands.ICommand`1.Id"/> of the <see cref="T:Cqrs.Commands.ICommand`1"/> that was issued.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.DuplicateEventException`2">
            <summary>
            The <see cref="T:Cqrs.Events.IEventStore`1"/> gave more than one <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.</typeparam>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.DuplicateEventException`2.#ctor(System.Guid,System.Int32)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.DuplicateEventException`2"/> with the provided identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see>.
            and the <paramref name="version"/> that had more than one <see cref="T:Cqrs.Events.IEvent`1"/> provided.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had <see cref="T:Cqrs.Events.IEvent`1">events</see>.</param>
            <param name="version">The version number of the duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see></param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.DuplicateEventException`2.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see>..
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.DuplicateEventException`2.AggregateType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had duplicate <see cref="T:Cqrs.Events.IEvent`1">events</see>..
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.EventsOutOfOrderException">
            <summary>
            The <see cref="T:Cqrs.Events.IEventStore`1"/> gave <see cref="T:Cqrs.Events.IEvent`1">events</see> out of order
            or an expected <see cref="T:Cqrs.Events.IEvent`1"/> with a specific version number wasn't provided.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.EventsOutOfOrderException.#ctor(System.Guid,System.Type,System.Int32,System.Int32)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.EventsOutOfOrderException"/> with the provided identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had out of order <see cref="T:Cqrs.Events.IEvent`1"/>.
            and the <paramref name="currentVersion"/> the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> was at and the <paramref name="providedEventVersion">the event version that was provided</paramref>.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had <see cref="T:Cqrs.Events.IEvent`1">events</see>.</param>
            <param name="aggregateType">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that the <see cref="T:Cqrs.Events.IEvent`1"/> was trying to be saved on.</param>
            <param name="currentVersion">The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> was at when it received an out of order <see cref="T:Cqrs.Events.IEvent`1"/>.</param>
            <param name="providedEventVersion">The version number the <see cref="T:Cqrs.Events.IEvent`1"/> that was provided, that was out of order.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.EventsOutOfOrderException.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had out of order <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.EventsOutOfOrderException.AggregateType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had out of order <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.EventsOutOfOrderException.CurrentVersion">
            <summary>
            The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> was at when it received an out of order <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.EventsOutOfOrderException.ProvidedEventVersion">
            <summary>
            The version number the <see cref="T:Cqrs.Events.IEvent`1"/> that was provided, that was out of order.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException">
            <summary>
            A parameterless constructor is missing.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException.#ctor(System.Type)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException"/> with the <see cref="P:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException.Type"/> of the object that needs to have a parameterless constructor.
            </summary>
            <param name="type">The <see cref="P:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException.Type"/> of the object that needs to have a parameterless constructor.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException.Type">
            <summary>
            The <see cref="P:Cqrs.Domain.Exceptions.MissingParameterLessConstructorException.Type"/> of the object that needs to have a parameterless constructor.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Factories.IAggregateFactory">
            <summary>
            A factory for creating instances of aggregates.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Factories.IAggregateFactory.Create``1(System.Nullable{System.Guid},System.Boolean)">
            <summary>
            Creates instance of <typeparamref name="TAggregate"/>.
            </summary>
            <typeparam name="TAggregate">The <see cref="T:System.Type"/> of the aggregate to create.</typeparam>
            <param name="rsn">The identifier of the aggregate to create an instance of if an existing aggregate.</param>
            <param name="tryDependencyResolutionFirst">Indicates the use of <see cref="T:Cqrs.Configuration.IDependencyResolver"/> should be tried first.</param>
        </member>
        <member name="M:Cqrs.Domain.Factories.IAggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)">
            <summary>
            Creates instance of type <paramref name="aggregateType"/>
            </summary>
            <param name="aggregateType">The <see cref="T:System.Type"/> of the aggregate to create.</param>
            <param name="rsn">The identifier of the aggregate to create an instance of if an existing aggregate.</param>
            <param name="tryDependencyResolutionFirst">Indicates the use of <see cref="T:Cqrs.Configuration.IDependencyResolver"/> should be tried first.</param>
        </member>
        <member name="T:Cqrs.Domain.IDto">
            <summary>
            A basic data transfer object suitable for CRUD operations.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.IDto.Id">
            <summary>
            The identifier of this <see cref="T:Cqrs.Domain.IDto"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.IUnitOfWork`1">
            <summary>
            Provides a basic container to control when <see cref="T:Cqrs.Events.IEvent`1">events</see> are store in an <see cref="T:Cqrs.Events.IEventStore`1"/> and then published on an <see cref="T:Cqrs.Events.IEventPublisher`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.IUnitOfWork`1.Add``1(``0)">
            <summary>
            Add an item into the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> ready to be committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.IUnitOfWork`1.Get``1(System.Guid,System.Nullable{System.Int32})">
            <summary>
            Get an item from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> if it has already been loaded.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.IUnitOfWork`1.Commit">
            <summary>
            Commit any changed <see cref="T:Cqrs.Domain.AggregateRoot`1"/> added to this <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> via <see cref="M:Cqrs.Domain.IUnitOfWork`1.Add``1(``0)"/>
            </summary>
        </member>
        <member name="T:Cqrs.Domain.SagaUnitOfWork`1">
            <summary>
            Provides a basic container to control when <see cref="T:Cqrs.Events.IEvent`1">events</see> are store in an <see cref="T:Cqrs.Events.IEventStore`1"/> and then published on an <see cref="T:Cqrs.Events.IEventPublisher`1"/>.
            </summary>
            <remarks>
            This shouldn't normally be used as a singleton.
            </remarks>
        </member>
        <member name="M:Cqrs.Domain.SagaUnitOfWork`1.#ctor(Cqrs.Domain.ISagaRepository{`0})">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.SagaUnitOfWork`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaUnitOfWork`1.Add``1(``0)">
            <summary>
            Add an item into the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> ready to be committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaUnitOfWork`1.Get``1(System.Guid,System.Nullable{System.Int32})">
            <summary>
            Get an item from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> if it has already been loaded or get it from the <see cref="T:Cqrs.Domain.ISagaRepository`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.SagaUnitOfWork`1.Commit">
            <summary>
            Commit any changed <see cref="T:Cqrs.Domain.Saga`1"/> added to this <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> via <see cref="M:Cqrs.Domain.SagaUnitOfWork`1.Add``1(``0)"/>
            into the <see cref="T:Cqrs.Domain.ISagaRepository`1"/>
            </summary>
        </member>
        <member name="T:Cqrs.Domain.UnitOfWork`1">
            <summary>
            Provides a basic container to control when <see cref="T:Cqrs.Events.IEvent`1">events</see> are store in an <see cref="T:Cqrs.Events.IEventStore`1"/> and then published on an <see cref="T:Cqrs.Events.IEventPublisher`1"/>.
            </summary>
            <remarks>
            This shouldn't normally be used as a singleton.
            </remarks>
        </member>
        <member name="M:Cqrs.Domain.UnitOfWork`1.#ctor(Cqrs.Domain.IAggregateRepository{`0})">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.UnitOfWork`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Domain.UnitOfWork`1.Add``1(``0)">
            <summary>
            Add an item into the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> ready to be committed.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.UnitOfWork`1.Get``1(System.Guid,System.Nullable{System.Int32})">
            <summary>
            Get an item from the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> if it has already been loaded or get it from the <see cref="T:Cqrs.Domain.IAggregateRepository`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.UnitOfWork`1.Commit">
            <summary>
            Commit any changed <see cref="T:Cqrs.Domain.AggregateRoot`1"/> added to this <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> via <see cref="M:Cqrs.Domain.UnitOfWork`1.Add``1(``0)"/>
            into the <see cref="T:Cqrs.Domain.IAggregateRepository`1"/>
            </summary>
        </member>
        <member name="T:Cqrs.Domain.DtoAggregateRoot`2">
            <summary>
            An <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> for operating on <see cref="T:Cqrs.Domain.IDto"/> instances.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
            <typeparam name="TDto">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IDto"/>.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.DtoAggregateRoot`2.#ctor(System.Guid,`1,`1)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.DtoAggregateRoot`2"/>
            and instantly apply the change as n <see cref="T:Cqrs.Events.DtoAggregateEvent`2"/>
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.IDto"/>.</param>
            <param name="original">The original copy of the <see cref="T:Cqrs.Domain.IDto"/>. May be null for a <see cref="F:Cqrs.Events.DtoAggregateEventType.Created"/> operation.</param>
            <param name="new">The new copy of the <see cref="T:Cqrs.Domain.IDto"/>. May be null for a <see cref="F:Cqrs.Events.DtoAggregateEventType.Deleted"/> operation.</param>
        </member>
        <member name="T:Cqrs.Entities.IEntity">
            <summary>
            A projection/entity.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.IEntity.Rsn">
            <summary>
            The identifier of the <see cref="T:Cqrs.Entities.IEntity"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.IEntity.SortingOrder">
            <summary>
            The order of this <see cref="T:Cqrs.Entities.IEntity"/> to sort by, by default.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.IEntity.IsLogicallyDeleted">
            <summary>
            Indicates if this <see cref="T:Cqrs.Entities.IEntity"/> has been deleted, but not removed from the <see cref="T:Cqrs.DataStores.IDataStore`1"/>,
            this way entities can be retrieved so an un-deleted operation can be triggered.
            </summary>
        </member>
        <member name="T:Cqrs.Entities.DecimalRange">
            <summary>
            A <see cref="T:Cqrs.Entities.Range`1"/> object for collecting a <see cref="T:System.Decimal"/> lower and upper limit.
            </summary>
        </member>
        <member name="T:Cqrs.Entities.Range`1">
            <summary>
            A range object for collecting a lower and upper limit, such as a number or date range.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Range`1.From">
            <summary>
            The lower limit such as a from <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Range`1.To">
            <summary>
            The upper limit such as a to <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Range`1.IsFromInclusive">
            <summary>
            Is the value of <see cref="P:Cqrs.Entities.Range`1.From"/> inclusive or not. Defaults to true.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Range`1.IsToInclusive">
            <summary>
            Is the value of <see cref="P:Cqrs.Entities.Range`1.To"/> inclusive or not. Defaults to true.
            </summary>
        </member>
        <member name="M:Cqrs.Entities.DecimalRange.#ctor">
            <summary>
            Instantiates and Initialises a new instance of the <see cref="T:Cqrs.Entities.DecimalRange"/> class.
            </summary>
        </member>
        <member name="T:Cqrs.Entities.IntegerRange">
            <summary>
            A <see cref="T:Cqrs.Entities.Range`1"/> object for collecting a <see cref="T:System.Int32"/> lower and upper limit.
            </summary>
        </member>
        <member name="M:Cqrs.Entities.IntegerRange.#ctor">
            <summary>
            Instantiates and Initialises a new instance of the <see cref="T:Cqrs.Entities.IntegerRange"/> class.
            </summary>
        </member>
        <member name="T:Cqrs.Entities.DateRange">
            <summary>
            A <see cref="T:Cqrs.Entities.Range`1"/> object for collecting a <see cref="T:System.DateTime"/> lower and upper limit.
            </summary>
        </member>
        <member name="M:Cqrs.Entities.DateRange.#ctor">
            <summary>
            Instantiates and Initialises a new instance of the <see cref="T:Cqrs.Entities.DateRange"/> class.
            </summary>
        </member>
        <member name="T:Cqrs.Entities.Entity">
            <summary>
            A projection/entity.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Entity.Rsn">
            <summary>
            The identifier of the <see cref="T:Cqrs.Entities.IEntity"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Entity.SortingOrder">
            <summary>
            The order of this <see cref="T:Cqrs.Entities.IEntity"/> to sort by, by default.
            </summary>
        </member>
        <member name="P:Cqrs.Entities.Entity.IsLogicallyDeleted">
            <summary>
            Indicates if this <see cref="T:Cqrs.Entities.IEntity"/> has been deleted, but not removed from the <see cref="T:Cqrs.DataStores.IDataStore`1"/>,
            this way entities can be retrieved so an un-deleted operation can be triggered.
            </summary>
        </member>
        <member name="T:Cqrs.Events.DefaultJsonSerializerSettings">
            <summary>
            Default settings for JSON serialisation  and deserialisation.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DefaultJsonSerializerSettings.DefaultSettings">
            <summary>
            System wide default <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Events.InProcessEventStore`1">
            <summary>
            An <see cref="T:Cqrs.Events.IEventStore`1"/> that uses a local (non-static) <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            This does not manage memory in any way and will continue to grow. Mostly suitable for running tests or short lived processes.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Events.IEventStore`1">
            <summary>
            Stores instances of <see cref="T:Cqrs.Events.IEvent`1"/> for replay, <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> and <see cref="T:Cqrs.Domain.ISaga`1"/> rehydration.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Events.IEventStore`1.Save``1(Cqrs.Events.IEvent{`0})">
            <summary>
            Saves the provided <paramref name="event"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to be saved.</param>
        </member>
        <member name="M:Cqrs.Events.IEventStore`1.Save(System.Type,Cqrs.Events.IEvent{`0})">
            <summary>
            Saves the provided <paramref name="event"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to be saved.</param>
        </member>
        <member name="M:Cqrs.Events.IEventStore`1.Get``1(System.Guid,System.Boolean,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <typeparamref name="T">aggregate root</typeparamref> with the ID matching the provided <paramref name="aggregateId"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="useLastEventOnly">Loads only the last event<see cref="T:Cqrs.Events.IEvent`1"/>.</param>
            <param name="fromVersion">Load events starting from this version</param>
        </member>
        <member name="M:Cqrs.Events.IEventStore`1.Get(System.Type,System.Guid,System.Boolean,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <paramref name="aggregateRootType"/> with the ID matching the provided <paramref name="aggregateId"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="useLastEventOnly">Loads only the last event<see cref="T:Cqrs.Events.IEvent`1"/>.</param>
            <param name="fromVersion">Load events starting from this version</param>
        </member>
        <member name="M:Cqrs.Events.IEventStore`1.Get(System.Guid)">
            <summary>
            Get all <see cref="T:Cqrs.Events.IEvent`1"/> instances for the given <paramref name="correlationId"/>.
            </summary>
            <param name="correlationId">The <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> instances to retrieve.</param>
        </member>
        <member name="M:Cqrs.Events.InProcessEventStore`1.#ctor">
            <summary>
            Instantiate a new instance of the <see cref="T:Cqrs.Events.InProcessEventStore`1"/> class.
            </summary>
        </member>
        <member name="M:Cqrs.Events.InProcessEventStore`1.Save(System.Type,Cqrs.Events.IEvent{`0})">
            <summary>
            Saves the provided <paramref name="event"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to be saved.</param>
        </member>
        <member name="M:Cqrs.Events.InProcessEventStore`1.Get``1(System.Guid,System.Boolean,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <typeparamref name="T">aggregate root</typeparamref> with the ID matching the provided <paramref name="aggregateId"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="useLastEventOnly">Loads only the last event<see cref="T:Cqrs.Events.IEvent`1"/>.</param>
            <param name="fromVersion">Load events starting from this version</param>
        </member>
        <member name="M:Cqrs.Events.InProcessEventStore`1.Get(System.Type,System.Guid,System.Boolean,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <paramref name="aggregateType"/> with the ID matching the provided <paramref name="aggregateId"/>.
            </summary>
            <param name="aggregateType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="useLastEventOnly">Loads only the last event<see cref="T:Cqrs.Events.IEvent`1"/>.</param>
            <param name="fromVersion">Load events starting from this version</param>
        </member>
        <member name="M:Cqrs.Events.InProcessEventStore`1.Get(System.Guid)">
            <summary>
            Get all <see cref="T:Cqrs.Events.IEvent`1"/> instances for the given <paramref name="correlationId"/>.
            </summary>
            <param name="correlationId">The <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> instances to retrieve.</param>
        </member>
        <member name="M:Cqrs.Events.InProcessEventStore`1.Save``1(Cqrs.Events.IEvent{`0})">
            <summary>
            Saves the provided <paramref name="event"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to be saved.</param>
        </member>
        <member name="P:Cqrs.Events.InProcessEventStore`1.InMemoryDb">
            <summary>
            Gets or sets the in-memory storage <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Events.ReplicatedSqlEventStore`1">
            <summary>
            A simplified SqlServer based <see cref="T:Cqrs.Events.EventStore`1"/> that uses LinqToSql and follows a rigid schema that also replicates to multiple connections, but only reads from one connection.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Events.SqlEventStore`1">
            <summary>
            A simplified SqlServer based <see cref="T:Cqrs.Events.EventStore`1"/> that uses LinqToSql and follows a rigid schema.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Events.EventStore`1">
            <summary>
            Stores instances of <see cref="T:Cqrs.Events.IEvent`1"/> for replay, <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> and <see cref="T:Cqrs.Domain.ISaga`1"/> rehydration.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="F:Cqrs.Events.EventStore`1.CqrsEventStoreStreamNamePattern">
            <summary>
            The pattern used to generate the stream name.
            </summary>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.#ctor(Cqrs.Events.IEventBuilder{`0},Cqrs.Events.IEventDeserialiser{`0},cdmdotnet.Logging.ILogger)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Events.EventStore`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.Save``1(Cqrs.Events.IEvent{`0})">
            <summary>
            Saves the provided <paramref name="event"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to be saved.</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.GenerateStreamName(System.Type,Cqrs.Events.IEvent{`0})">
            <summary>
            Generate a unique stream name based on the provided <paramref name="aggregateRootType"/> and the <see cref="P:Cqrs.Events.IEvent`1.Id"/> from the provided <paramref name="event"/>.
            </summary>
            <param name="aggregateRootType">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to extract information from.</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.GenerateStreamName(System.Type,System.Guid)">
            <summary>
            Generate a unique stream name based on the provided <paramref name="aggregateRootType"/> and the <paramref name="aggregateId"/>.
            </summary>
            <param name="aggregateRootType">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="aggregateId">The ID of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.Save(System.Type,Cqrs.Events.IEvent{`0})">
            <summary>
            Saves the provided <paramref name="event"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="event">The <see cref="T:Cqrs.Events.IEvent`1"/> to be saved.</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.Get``1(System.Guid,System.Boolean,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <typeparamref name="T">aggregate root</typeparamref> with the ID matching the provided <paramref name="aggregateId"/>.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</typeparam>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="useLastEventOnly">Loads only the last event<see cref="T:Cqrs.Events.IEvent`1"/>.</param>
            <param name="fromVersion">Load events starting from this version</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.Get(System.Type,System.Guid,System.Boolean,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <paramref name="aggregateRootType"/> with the ID matching the provided <paramref name="aggregateId"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="useLastEventOnly">Loads only the last event<see cref="T:Cqrs.Events.IEvent`1"/>.</param>
            <param name="fromVersion">Load events starting from this version</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.Get(System.Guid)">
            <summary>
            Get all <see cref="T:Cqrs.Events.IEvent`1"/> instances for the given <paramref name="correlationId"/>.
            </summary>
            <param name="correlationId">The <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> instances to retrieve.</param>
        </member>
        <member name="M:Cqrs.Events.EventStore`1.PersistEvent(Cqrs.Events.EventData)">
            <summary>
            Persist the provided <paramref name="eventData"/> into storage.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.EventData"/> to persist.</param>
        </member>
        <member name="P:Cqrs.Events.EventStore`1.EventBuilder">
            <summary>
            The <see cref="T:Cqrs.Events.IEventBuilder`1"/> used to build events.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventStore`1.EventDeserialiser">
            <summary>
            The <see cref="T:Cqrs.Events.IEventDeserialiser`1"/> used to deserialise events.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventStore`1.TelemetryHelper">
            <summary>
            The <see cref="T:cdmdotnet.Logging.ITelemetryHelper"/> to use.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventStore`1.Logger">
            <summary>
            The <see cref="T:cdmdotnet.Logging.ILogger"/> to use.
            </summary>
        </member>
        <member name="M:Cqrs.Events.SqlEventStore`1.#ctor(Cqrs.Events.IEventBuilder{`0},Cqrs.Events.IEventDeserialiser{`0},cdmdotnet.Logging.ILogger,Cqrs.Configuration.IConfigurationManager)">
            <summary>
            Instantiate a new instance of the <see cref="T:Cqrs.Events.SqlEventStore`1"/> class.
            </summary>
        </member>
        <member name="M:Cqrs.Events.SqlEventStore`1.Get(System.Type,System.Guid,System.Boolean,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <paramref name="aggregateRootType"/> with the ID matching the provided <paramref name="aggregateId"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="useLastEventOnly">Loads only the last event<see cref="T:Cqrs.Events.IEvent`1"/>.</param>
            <param name="fromVersion">Load events starting from this version</param>
        </member>
        <member name="M:Cqrs.Events.SqlEventStore`1.Get(System.Guid)">
            <summary>
            Get all <see cref="T:Cqrs.Events.IEvent`1"/> instances for the given <paramref name="correlationId"/>.
            </summary>
            <param name="correlationId">The <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> instances to retrieve.</param>
        </member>
        <member name="M:Cqrs.Events.SqlEventStore`1.PersistEvent(Cqrs.Events.EventData)">
            <summary>
            Persist the provided <paramref name="eventData"/> into SQL Server.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.EventData"/> to persist.</param>
        </member>
        <member name="M:Cqrs.Events.SqlEventStore`1.CreateDbDataContext">
            <summary>
            Creates a new <see cref="T:System.Data.Linq.DataContext"/> using connection string settings from <see cref="P:Cqrs.Events.SqlEventStore`1.ConfigurationManager"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Events.SqlEventStore`1.GetEventStoreTable(System.Data.Linq.DataContext)">
            <summary>
            Gets the <see cref="T:System.Data.Linq.Table`1"/> of <see cref="T:Cqrs.Events.EventData"/>.
            </summary>
            <param name="dbDataContext">The <see cref="T:System.Data.Linq.DataContext"/> to use.</param>
        </member>
        <member name="M:Cqrs.Events.SqlEventStore`1.Add(System.Data.Linq.DataContext,Cqrs.Events.EventData)">
            <summary>
            Persist the provided <paramref name="data"/> into SQL Server using the provided <paramref name="dbDataContext"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.SqlEventStore`1.ConfigurationManager">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Configuration.IConfigurationManager"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Events.ReplicatedSqlEventStore`1.#ctor(Cqrs.Events.IEventBuilder{`0},Cqrs.Events.IEventDeserialiser{`0},cdmdotnet.Logging.ILogger,Cqrs.Configuration.IConfigurationManager)">
            <summary>
            Instantiates and Initialises a new instance of the <see cref="T:Cqrs.Events.ReplicatedSqlEventStore`1"/> class.
            </summary>
        </member>
        <member name="M:Cqrs.Events.ReplicatedSqlEventStore`1.PersistEvent(Cqrs.Events.EventData)">
            <summary>
            Persist the provided <paramref name="eventData"/> into each SQL Server in <see cref="P:Cqrs.Events.ReplicatedSqlEventStore`1.WritableConnectionStrings"/>.
            A single <see cref="T:System.Transactions.TransactionScope"/> wraps all SQL servers, so all must complete successfully, or they will ALL roll back.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.EventData"/> to persist.</param>
        </member>
        <member name="P:Cqrs.Events.ReplicatedSqlEventStore`1.WritableConnectionStrings">
            <summary>
            A collection of connection strings that are used to write to the database.
            </summary>
        </member>
        <member name="T:Cqrs.Events.SagaEvent`1">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> used specifically by a <see cref="T:Cqrs.Domain.ISaga`1"/>
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Events.ISagaEvent`1">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> used specifically by a <see cref="T:Cqrs.Domain.ISaga`1"/>
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Events.IEvent`1">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> represents something that took place in the domain. They are always named with a past-participle verb, such as OrderConfirmed. It's not unusual, but not required, for an <see cref="T:Cqrs.Events.IEvent`1"/> to name an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Entities.IEntity"/> that it relates to; let the domain language be your guide.
            
            Since an <see cref="T:Cqrs.Events.IEvent`1"/> represents something in the past, it can be considered a statement of fact and used to take decisions in other parts of the system.
            </summary>
            <example>
            public class OrderConfirmed 
            {
            	public Guid OrderRsn;
            	public DateTime ConfirmationDate;
            }
            </example>
            <remarks>
            What does a <see cref="T:Cqrs.Commands.ICommand`1"/> or an <see cref="T:Cqrs.Events.IEvent`1"/> look like?
            
            An <see cref="T:Cqrs.Commands.ICommand`1"/> or <see cref="T:Cqrs.Events.IEvent`1"/> is simply a data structure that contain data for reading, and no behavior. We call such structures "Data Transfer Objects" (DTOs). The name indicates the purpose. In many languages they are represented as classes, but they are not true classes in the real OO sense.
            
            
            What is the difference between a <see cref="T:Cqrs.Commands.ICommand`1"/> and an <see cref="T:Cqrs.Events.IEvent`1"/>?
            
            Their intent.
            
            
            What is immutability? Why is a <see cref="T:Cqrs.Commands.ICommand`1"/> or <see cref="T:Cqrs.Events.IEvent`1"/> immutable?
            
            For the purpose of this question, immutability is not having any setters, or other methods which change internal state. The <see cref="T:System.String"/> type in is a familiar example; you never actually change an existing <see cref="T:System.String"/> value, you just create new <see cref="T:System.String"/> values based on old ones.
            
            An <see cref="T:Cqrs.Commands.ICommand`1"/> is immutable because their expected usage is to be sent directly to the domain model side for processing. They do not need to change during their projected lifetime in traveling from client to server.
            Sometimes however business logic dictates that a decision may be made to construct a <see cref="T:Cqrs.Commands.ICommand`1"/> and local variables should be used.
            
            An <see cref="T:Cqrs.Events.IEvent`1"/> is immutable because they represent domain actions that took place in the past. Unless you're Marty McFly, you can't change the past, and sometimes not even then.
            
            
            What is command upgrading?
            
            Upgrading an <see cref="T:Cqrs.Commands.ICommand`1"/> becomes necessary when new requirements cause an existing <see cref="T:Cqrs.Commands.ICommand`1"/> not to be sufficient. Maybe a new field needs to be added, for example, or maybe an existing field should really have been split into several different ones.
            
            
            How do I upgrade my <see cref="T:Cqrs.Commands.ICommand`1"/>s?
            
            How you do the upgrade depends how much control you have over your clients. If you can deploy your client updates and server updates together, just change things in both and deploy the updates. Job done. If not, it's usually best to have the updated <see cref="T:Cqrs.Commands.ICommand`1"/> be a new type and have the <see cref="T:Cqrs.Commands.ICommandHandler`2"/> accept both for a while.
            
            
            Could you give an example of names of some versioned <see cref="T:Cqrs.Commands.ICommand`1"/>?
            
            Sure.
            
            UploadFile
            UploadFile_v2
            UploadFile_v3
            
            It's just a convention, but a sane one.
            ********************************************
            Also see http://cqrs.nu/Faq/commands-and-events.
            </remarks>
        </member>
        <member name="P:Cqrs.Events.IEvent`1.Id">
            <summary>
            The ID of the <see cref="T:Cqrs.Events.IEvent`1"/>
            </summary>
        </member>
        <member name="P:Cqrs.Events.IEvent`1.Version">
            <summary>
            The version of the <see cref="T:Cqrs.Events.IEvent`1"/>
            </summary>
        </member>
        <member name="P:Cqrs.Events.IEvent`1.TimeStamp">
            <summary>
            The date and time the event was raised or published.
            </summary>
        </member>
        <member name="P:Cqrs.Events.ISagaEvent`1.Event">
            <summary>
            The <see cref="T:Cqrs.Events.IEvent`1"/> this <see cref="T:Cqrs.Events.ISagaEvent`1"/> encases.
            </summary>
        </member>
        <member name="M:Cqrs.Events.SagaEvent`1.#ctor">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Events.SagaEvent`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Events.SagaEvent`1.#ctor(Cqrs.Events.IEvent{`0})">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Events.SagaEvent`1"/> with the provided <paramref name="event"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.SagaEvent`1.CorrelationId">
            <summary>
            An identifier used to group together several <see cref="T:Cqrs.Messages.IMessage"/>. Any <see cref="T:Cqrs.Messages.IMessage"/> with the same <see cref="P:Cqrs.Events.SagaEvent`1.CorrelationId"/> were triggered by the same initiating request.
            </summary>
        </member>
        <member name="P:Cqrs.Events.SagaEvent`1.OriginatingFramework">
            <summary>
            The originating framework this message was sent from.
            </summary>
        </member>
        <member name="P:Cqrs.Events.SagaEvent`1.Frameworks">
            <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage"/> has been delivered to/sent via already.
            </summary>
        </member>
        <member name="P:Cqrs.Events.SagaEvent`1.AuthenticationToken">
            <summary>
            The <typeparamref name="TAuthenticationToken"/> of the entity that triggered the event to be raised.
            </summary>
        </member>
        <member name="P:Cqrs.Events.SagaEvent`1.Id">
            <summary>
            The ID of the <see cref="T:Cqrs.Events.IEvent`1"/>
            </summary>
        </member>
        <member name="P:Cqrs.Events.SagaEvent`1.Version">
            <summary>
            The version of the <see cref="T:Cqrs.Events.IEvent`1"/>
            </summary>
        </member>
        <member name="P:Cqrs.Events.SagaEvent`1.TimeStamp">
            <summary>
            The date and time the event was raised or published.
            </summary>
        </member>
        <member name="P:Cqrs.Events.SagaEvent`1.Event">
            <summary>
            The <see cref="T:Cqrs.Events.IEvent`1"/> this <see cref="T:Cqrs.Events.ISagaEvent`1"/> encases.
            </summary>
        </member>
        <member name="T:Cqrs.Events.NotifyEveryoneExceptCallerEventAttribute">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> that should be sent to all connected people except the person who was authenticated when sending the request via SignalR.
            </summary>
        </member>
        <member name="T:Cqrs.Events.NotifyEveryoneEventAttribute">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> that should be sent to all connected people via SignalR.
            </summary>
        </member>
        <member name="T:Cqrs.Events.NotifyCallerEventAttribute">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> that should be sent back to the person who was authenticated when sending the request via SignalR.
            </summary>
        </member>
        <member name="T:Cqrs.Events.PrivateEventAttribute">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> that should be sent via the private <see cref="T:Cqrs.Events.IEventPublisher`1"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Events.EventDataResolver`1">
            <summary>
            Resolves <see cref="T:Cqrs.Events.EventData"/>, <see cref="T:Cqrs.Services.ServiceRequestWithData`2"/> and <see cref="T:Cqrs.Services.ServiceResponseWithResultData`1"/> parameter types when serialising with WCF.
            </summary>
        </member>
        <member name="T:Cqrs.Services.IEventDataResolver">
            <summary>
            Resolves <see cref="T:Cqrs.Events.EventData"/>, <see cref="T:Cqrs.Services.ServiceRequestWithData`2"/> and <see cref="T:Cqrs.Services.ServiceResponseWithResultData`1"/> parameter types when serialising with WCF.
            </summary>
        </member>
        <member name="M:Cqrs.Events.EventDataResolver`1.TryResolveType(System.Type,System.Type,System.Runtime.Serialization.DataContractResolver,System.Xml.XmlDictionaryString@,System.Xml.XmlDictionaryString@)">
            <summary>
            Indicates if the provided <paramref name="dataContractType"/> is of type <see cref="T:Cqrs.Events.EventData"/>, <see cref="T:Cqrs.Services.ServiceRequestWithData`2"/>, <see cref="T:Cqrs.Services.ServiceResponseWithResultData`1"/>0
            OR if it is other resolvable.
            </summary>
        </member>
        <member name="M:Cqrs.Events.EventDataResolver`1.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
            <summary>
            Returns the <see cref="T:System.Type"/> if the <paramref name="typeName"/> is resolvable or if it is 
            of type <paramref name="typeName"/> is of type <see cref="T:Cqrs.Events.EventData"/>, <see cref="T:Cqrs.Services.ServiceRequestWithData`2"/>, <see cref="T:Cqrs.Services.ServiceResponseWithResultData`1"/>
            </summary>
        </member>
        <member name="T:Cqrs.Events.EventStoreRetentionLevelAttribute">
            <summary>
            Provides a mechanism to configure different <see cref="T:Cqrs.Events.IEventStore`1"/> instances to save the event to.
            This is useful if you have events that should be in hot storage with quick loads and events that should be in cold storage and are unlikely to be reloaded and use slower cheaper storage.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventStoreRetentionLevelAttribute.RetentionLevel">
            <summary>
            The level of retention required. By specifying a value we look for a matching configured <see cref="T:Cqrs.Events.IEventStore`1"/> with the same level defined.
            </summary>
        </member>
        <member name="T:Cqrs.Events.MemoryCacheEventStore`1">
            <summary>
            A, <see cref="T:Cqrs.Events.EventStore`1"/> that uses a <see cref="T:System.Runtime.Caching.MemoryCache"/> implementation, flushing out data (I.E. it's not persisted)
            </summary>
        </member>
        <member name="M:Cqrs.Events.MemoryCacheEventStore`1.#ctor(Cqrs.Configuration.IConfigurationManager,Cqrs.Events.IEventBuilder{`0},Cqrs.Events.IEventDeserialiser{`0},cdmdotnet.Logging.ILogger)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Events.MemoryCacheEventStore`1"/> and calls <see cref="M:Cqrs.Events.MemoryCacheEventStore`1.StartRefreshSlidingExpirationValue"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Events.MemoryCacheEventStore`1.Get(System.Type,System.Guid,System.Boolean,System.Int32)">
            <summary>
            Gets a collection of <see cref="T:Cqrs.Events.IEvent`1"/> for the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <paramref name="aggregateRootType"/> with the ID matching the provided <paramref name="aggregateId"/>.
            </summary>
            <param name="aggregateRootType"> <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> the <see cref="T:Cqrs.Events.IEvent`1"/> was raised in.</param>
            <param name="aggregateId">The <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</param>
            <param name="useLastEventOnly">Loads only the last event<see cref="T:Cqrs.Events.IEvent`1"/>.</param>
            <param name="fromVersion">Load events starting from this version</param>
        </member>
        <member name="M:Cqrs.Events.MemoryCacheEventStore`1.Get(System.Guid)">
            <summary>
            Get all <see cref="T:Cqrs.Events.IEvent`1"/> instances for the given <paramref name="correlationId"/>.
            </summary>
            <param name="correlationId">The <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/> of the <see cref="T:Cqrs.Events.IEvent`1"/> instances to retrieve.</param>
        </member>
        <member name="M:Cqrs.Events.MemoryCacheEventStore`1.PersistEvent(Cqrs.Events.EventData)">
            <summary>
            Persist the provided <paramref name="eventData"/> into storage.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.EventData"/> to persist.</param>
        </member>
        <member name="M:Cqrs.Events.MemoryCacheEventStore`1.RefreshSlidingExpirationValue">
            <summary>
            Reads "Cqrs.EventStore.MemoryCacheEventStore.SlidingExpiration" from <see cref="P:Cqrs.Events.MemoryCacheEventStore`1.ConfigurationManager"/>, checks if it has changed and then
            Update <see cref="P:Cqrs.Events.MemoryCacheEventStore`1.SlidingExpiration"/> with the new value.
            </summary>
        </member>
        <member name="M:Cqrs.Events.MemoryCacheEventStore`1.StartRefreshSlidingExpirationValue">
            <summary>
            Start a <see cref="T:System.Threading.Tasks.Task"/> that will call <see cref="M:Cqrs.Events.MemoryCacheEventStore`1.RefreshSlidingExpirationValue"/> in a loop with a 1 second wait time between loops.
            </summary>
        </member>
        <member name="M:Cqrs.Events.MemoryCacheEventStore`1.GetDetaultCacheItemPolicy">
            <summary>
            Get's a <see cref="T:System.Runtime.Caching.CacheItemPolicy"/> with the <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration"/> set to 15 minutes
            </summary>
        </member>
        <member name="P:Cqrs.Events.MemoryCacheEventStore`1.ConfigurationManager">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Configuration.IConfigurationManager"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.MemoryCacheEventStore`1.EventStoreByType">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Caching.MemoryCache"/> of data grouped by event <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.MemoryCacheEventStore`1.EventStoreByCorrelationId">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Caching.MemoryCache"/> of data grouped by event <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.MemoryCacheEventStore`1.SlidingExpirationValue">
            <summary>
            Gets of sets the SlidingExpirationValue, the value of "Cqrs.EventStore.MemoryCacheEventStore.SlidingExpiration" from <see cref="P:Cqrs.Events.MemoryCacheEventStore`1.ConfigurationManager"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.MemoryCacheEventStore`1.SlidingExpiration">
            <summary>
            Gets of sets the SlidingExpiration
            </summary>
        </member>
        <member name="T:Cqrs.Events.DefaultEventBuilder`1">
            <summary>
            Builds <see cref="T:Cqrs.Events.EventData"/> from various input formats serialising as JSON.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Events.EventBuilder`1">
            <summary>
            Builds <see cref="T:Cqrs.Events.EventData"/> from various input formats.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Events.IEventBuilder`1">
            <summary>
            Builds <see cref="T:Cqrs.Events.EventData"/> from various input formats.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Events.IEventBuilder`1.CreateFrameworkEvent(Cqrs.Events.IEvent{`0})">
            <summary>
            Create an <see cref="T:Cqrs.Events.EventData">framework event</see> with the provided <paramref name="eventData"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to add to the <see cref="T:Cqrs.Events.EventData"/>.</param>
        </member>
        <member name="M:Cqrs.Events.IEventBuilder`1.CreateFrameworkEvent(System.String,Cqrs.Events.IEvent{`0})">
            <summary>
            Create an <see cref="T:Cqrs.Events.EventData">framework event</see> with the provided <paramref name="eventData"/>.
            </summary>
            <param name="type">The name of the <see cref="T:System.Type"/> of the target object the serialised data is.</param>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to add to the <see cref="T:Cqrs.Events.EventData"/>.</param>
        </member>
        <member name="M:Cqrs.Events.EventBuilder`1.CreateFrameworkEvent(System.String,Cqrs.Events.IEvent{`0})">
            <summary>
            Create an <see cref="T:Cqrs.Events.EventData">framework event</see> with the provided <paramref name="eventData"/>.
            </summary>
            <param name="type">The name of the <see cref="T:System.Type"/> of the target object the serialised data is.</param>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to add to the <see cref="T:Cqrs.Events.EventData"/>.</param>
        </member>
        <member name="M:Cqrs.Events.EventBuilder`1.CreateFrameworkEvent(Cqrs.Events.IEvent{`0})">
            <summary>
            Create an <see cref="T:Cqrs.Events.EventData">framework event</see> with the provided <paramref name="eventData"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to add to the <see cref="T:Cqrs.Events.EventData"/>.</param>
        </member>
        <member name="M:Cqrs.Events.EventBuilder`1.SerialiseEventData(Cqrs.Events.IEvent{`0})">
            <summary>
            Serialise the provided <paramref name="eventData"/> into a <see cref="T:System.Byte"/> <see cref="T:System.Array"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to serialise.</param>
        </member>
        <member name="M:Cqrs.Events.EventBuilder`1.SerialiseEventDataToString(Cqrs.Events.IEvent{`0})">
            <summary>
            Serialise the provided <paramref name="eventData"/> into a <see cref="T:System.String"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to serialise.</param>
        </member>
        <member name="M:Cqrs.Events.DefaultEventBuilder`1.SerialiseEventDataToString(Cqrs.Events.IEvent{`0})">
            <summary>
            Serialise the provided <paramref name="eventData"/> into JSON a <see cref="T:System.String"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.IEvent`1"/> to serialise.</param>
        </member>
        <member name="M:Cqrs.Events.DefaultEventBuilder`1.GetSerialisationSettings">
            <summary>
            Returns <see cref="P:Cqrs.Events.DefaultEventBuilder`1.DefaultSettings"/>
            </summary>
            <returns><see cref="P:Cqrs.Events.DefaultEventBuilder`1.DefaultSettings"/></returns>
        </member>
        <member name="P:Cqrs.Events.DefaultEventBuilder`1.DefaultSettings">
            <summary>
            The default <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> to use.
            </summary>
        </member>
        <member name="T:Cqrs.Events.DtoAggregateEventType">
            <summary>
            The type of CRUD operation.
            </summary>
        </member>
        <member name="F:Cqrs.Events.DtoAggregateEventType.Unknown">
            <summary>
            An unknown CRUD operations.
            </summary>
        </member>
        <member name="F:Cqrs.Events.DtoAggregateEventType.Created">
            <summary>
            The Create CRUD operations.
            </summary>
        </member>
        <member name="F:Cqrs.Events.DtoAggregateEventType.Updated">
            <summary>
            The Update CRUD operations.
            </summary>
        </member>
        <member name="F:Cqrs.Events.DtoAggregateEventType.Deleted">
            <summary>
            The Delete CRUD operations.
            </summary>
        </member>
        <member name="T:Cqrs.Events.DuplicateCreateCommandEvent`1">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> that informs the system that an operation resulted in a duplicate.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.Id">
            <summary>
            The identifier of the command itself.
            In some cases this may be the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> this command targets.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.Version">
            <summary>
            The new version number the targeted <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> that raised this.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.TimeStamp">
            <summary>
            The date and time the event was raised or published.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.AuthenticationToken">
            <summary>
            The <typeparamref name="TAuthenticationToken"/> of the entity that triggered the event to be raised.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.CorrelationId">
            <summary>
            An identifier used to group together several <see cref="T:Cqrs.Messages.IMessage"/>. Any <see cref="T:Cqrs.Messages.IMessage"/> with the same <see cref="P:Cqrs.Events.DuplicateCreateCommandEvent`1.CorrelationId"/> were triggered by the same initiating request.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.OriginatingFramework">
            <summary>
            The originating framework this message was sent from.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.Frameworks">
            <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage"/> has been delivered to/sent via already.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.AggregateType">
            <summary>
            The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that already exists, but had another <see cref="F:Cqrs.Events.DtoAggregateEventType.Created"/> event raised.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.AggregateRsn">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that already exists, but had another <see cref="F:Cqrs.Events.DtoAggregateEventType.Created"/> event raised.
            </summary>
        </member>
        <member name="T:Cqrs.Events.EventData">
            <summary>
            Captures all the data relevant to an <see cref="T:Cqrs.Events.IEvent`1"/> for an <see cref="T:Cqrs.Events.IEventStore`1"/> to persist.
            </summary>
        </member>
        <member name="M:Cqrs.Events.EventData.#ctor">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Events.EventData"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.Data">
            <summary>
            The data/content of the <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.EventId">
            <summary>
            The identifier of the <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.EventType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Events.IEvent`1"/>
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.AggregateId">
            <summary>
            The globally identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> , meaning it also includes <see cref="T:System.Type"/> information.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.AggregateRsn">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.Version">
            <summary>
            The new version number the targeted <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> that raised this.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.Timestamp">
            <summary>
            The date and time the event was raised or published.
            </summary>
        </member>
        <member name="P:Cqrs.Events.EventData.CorrelationId">
            <summary>
            An identifier used to group together several <see cref="T:Cqrs.Messages.IMessage"/>. Any <see cref="T:Cqrs.Messages.IMessage"/> with the same <see cref="P:Cqrs.Events.EventData.CorrelationId"/> were triggered by the same initiating request.
            </summary>
        </member>
        <member name="T:Cqrs.Events.EventDeserialiser`1">
            <summary>
            Deserialises <see cref="T:Cqrs.Events.IEvent`1"/> from a serialised state.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Events.IEventDeserialiser`1">
            <summary>
            Deserialises <see cref="T:Cqrs.Events.IEvent`1"/> from a serialised state.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Events.IEventDeserialiser`1.Deserialise(Cqrs.Events.EventData)">
            <summary>
            Deserialise the provided <paramref name="eventData"/> into an <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.EventData"/> to Deserialise.</param>
        </member>
        <member name="M:Cqrs.Events.EventDeserialiser`1.Deserialise(Cqrs.Events.EventData)">
            <summary>
            Deserialise the provided <paramref name="eventData"/> into an <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
            <param name="eventData">The <see cref="T:Cqrs.Events.EventData"/> to Deserialise.</param>
        </member>
        <member name="M:Cqrs.Events.EventDeserialiser`1.GetSerialisationSettings">
            <summary>
            Returns <see cref="P:Cqrs.Events.EventDeserialiser`1.DefaultSettings"/>
            </summary>
            <returns><see cref="P:Cqrs.Events.EventDeserialiser`1.DefaultSettings"/></returns>
        </member>
        <member name="P:Cqrs.Events.EventDeserialiser`1.DefaultSettings">
            <summary>
            The default <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> to use.
            </summary>
        </member>
        <member name="T:Cqrs.Events.IEventReceiver">
            <summary>
            Receives instances of a <see cref="T:Cqrs.Events.IEvent`1"/> from the event bus.
            </summary>
        </member>
        <member name="M:Cqrs.Events.IEventReceiver.Start">
            <summary>
            Starts listening and processing instances of <see cref="T:Cqrs.Events.IEvent`1"/> from the event bus.
            </summary>
        </member>
        <member name="T:Cqrs.Events.IEventReceiver`1">
            <summary>
            Receives instances of a <see cref="T:Cqrs.Events.IEvent`1"/> from the event bus.
            </summary>
        </member>
        <member name="M:Cqrs.Events.IEventReceiver`1.ReceiveEvent(Cqrs.Events.IEvent{`0})">
            <summary>
            Receives a <see cref="T:Cqrs.Events.IEvent`1"/> from the event bus.
            </summary>
        </member>
        <member name="T:Cqrs.Events.IEventPublisher`1">
            <summary>
            Publishes an <see cref="T:Cqrs.Events.IEvent`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Events.IEventPublisher`1.Publish``1(``0)">
            <summary>
            Publishes the provided <paramref name="event"/> on the event bus.
            </summary>
        </member>
        <member name="M:Cqrs.Events.IEventPublisher`1.Publish``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Publishes the provided <paramref name="events"/> on the event bus.
            </summary>
        </member>
        <member name="T:Cqrs.Events.IEventHandler`3">
            <summary>
            Responds to or "Handles" a <typeparamref name="TEvent"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
            <typeparam name="TTarget">The <see cref="T:System.Type"/> of the object that is targeted that needs concurrency.</typeparam>
            <typeparam name="TEvent">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Events.IEvent`1"/> that can be handled.</typeparam>
        </member>
        <member name="T:Cqrs.Events.IEventHandler`2">
            <summary>
            Responds to or "Handles" a <typeparamref name="TEvent"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
            <typeparam name="TEvent">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Events.IEvent`1"/> that can be handled.</typeparam>
        </member>
        <member name="T:Cqrs.Events.IEventHandler">
            <summary>
            Responds to or "Handles" a <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Events.DtoAggregateEvent`2">
            <summary>
            A <see cref="T:Cqrs.Events.IEvent`1"/> for <see cref="T:Cqrs.Domain.IDto"/> objects
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
            <typeparam name="TDto">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IDto"/> this command targets.</typeparam>
        </member>
        <member name="M:Cqrs.Events.DtoAggregateEvent`2.#ctor(System.Guid,`1,`1)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Events.DtoAggregateEvent`2"/>
            </summary>
        </member>
        <member name="M:Cqrs.Events.DtoAggregateEvent`2.GetEventType">
            <summary>
            Determines the <see cref="T:Cqrs.Events.DtoAggregateEventType"/> this <see cref="T:Cqrs.Events.IEvent`1"/> represents.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.Original">
            <summary>
            Gets or sets the original version of the <typeparamref name="TDto"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.New">
            <summary>
            Gets or sets the new version of the <typeparamref name="TDto"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.Id">
            <summary>
            The identifier of the event itself.
            In some cases this may be the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> this command targets.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.Version">
            <summary>
            The new version number the targeted <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> or <see cref="T:Cqrs.Domain.ISaga`1"/> that raised this.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.TimeStamp">
            <summary>
            The date and time the event was raised or published.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.AuthenticationToken">
            <summary>
            The <typeparamref name="TAuthenticationToken"/> of the entity that triggered the event to be raised.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.CorrelationId">
            <summary>
            An identifier used to group together several <see cref="T:Cqrs.Messages.IMessage"/>. Any <see cref="T:Cqrs.Messages.IMessage"/> with the same <see cref="P:Cqrs.Events.DtoAggregateEvent`2.CorrelationId"/> were triggered by the same initiating request.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.OriginatingFramework">
            <summary>
            The originating framework this message was sent from.
            </summary>
        </member>
        <member name="P:Cqrs.Events.DtoAggregateEvent`2.Frameworks">
            <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage"/> has been delivered to/sent via already.
            </summary>
        </member>
        <member name="T:Cqrs.Exceptions.NoEventHandlerRegisteredException">
            <summary>
            The <see cref="T:System.Exception"/> that is thrown when no <see cref="T:Cqrs.Events.IEventHandler"/> if found for a given <see cref="T:Cqrs.Events.IEvent`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Exceptions.NoEventHandlerRegisteredException.#ctor(System.Type)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Exceptions.NoEventHandlerRegisteredException"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Events.IEvent`1"/> that expected an <see cref="T:Cqrs.Events.IEventHandler"/>.</param>
        </member>
        <member name="M:Cqrs.Exceptions.NoEventHandlerRegisteredException.#ctor(System.String)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Exceptions.NoEventHandlerRegisteredException"/> with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:Cqrs.Events.PublicEventAttribute">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> that should be sent via the public <see cref="T:Cqrs.Events.IEventPublisher`1"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Exceptions.InvalidConfigurationException">
            <summary>
            A configuration caused an <see cref="T:System.Exception"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Exceptions.InvalidConfigurationException.#ctor(System.String,System.Exception)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Exceptions.InvalidConfigurationException"/> with a specified error message and a reference to the inner <paramref name="exception"/> that is the cause of this <see cref="T:System.Exception"/>.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="exception">The <see cref="T:System.Exception"/> that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner <see cref="T:System.Exception"/> is specified.</param>
        </member>
        <member name="T:Cqrs.Exceptions.MissingApplicationSettingForConnectionStringException">
            <summary>
            An app setting is missing from <see cref="P:System.Configuration.ConfigurationManager.AppSettings"/> that points to a connection string.
            </summary>
        </member>
        <member name="T:Cqrs.Exceptions.MissingApplicationSettingException">
            <summary>
            An app setting is missing from <see cref="P:System.Configuration.ConfigurationManager.AppSettings"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Exceptions.MissingApplicationSettingException.#ctor(System.String)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Exceptions.MissingApplicationSettingException"/>.
            </summary>
            <param name="appSettingKey">The key of the app setting that is missing.</param>
        </member>
        <member name="M:Cqrs.Exceptions.MissingApplicationSettingException.#ctor(System.String,System.String)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Exceptions.MissingApplicationSettingException"/> with a specified error message.
            </summary>
            <param name="appSettingKey">The key of the app setting that is missing.</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Cqrs.Exceptions.MissingApplicationSettingException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Exceptions.MissingApplicationSettingException"/> with a specified error message and  and a reference to the inner <paramref name="exception"/> that is the cause of this <see cref="T:System.Exception"/>
            </summary>
            <param name="appSettingKey">The key of the app setting that is missing.</param>
            <param name="message">The message that describes the error.</param>
            <param name="exception">The <see cref="T:System.Exception"/> that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner <see cref="T:System.Exception"/> is specified.</param>
        </member>
        <member name="M:Cqrs.Exceptions.MissingApplicationSettingException.#ctor(System.String,System.Boolean)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Exceptions.MissingApplicationSettingException"/>.
            </summary>
            <param name="appSettingKey">The key of the app setting that is missing.</param>
            <param name="settingLocatesConnectionString">If true, this missing app setting points to a connection string.</param>
        </member>
        <member name="M:Cqrs.Exceptions.MissingApplicationSettingException.#ctor(System.String,System.Exception)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Exceptions.MissingApplicationSettingException"/> and a reference to the inner <paramref name="exception"/> that is the cause of this <see cref="T:System.Exception"/>.
            </summary>
            <param name="appSettingKey">The key of the app setting that is missing.</param>
            <param name="exception">The <see cref="T:System.Exception"/> that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner <see cref="T:System.Exception"/> is specified.</param>
        </member>
        <member name="M:Cqrs.Exceptions.MissingApplicationSettingException.#ctor(System.String,System.Boolean,System.Exception)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Exceptions.MissingApplicationSettingException"/> and a reference to the inner <paramref name="exception"/> that is the cause of this <see cref="T:System.Exception"/>.
            </summary>
            <param name="appSettingKey">The key of the app setting that is missing.</param>
            <param name="settingLocatesConnectionString">If true, this missing app setting points to a connection string.</param>
            <param name="exception">The <see cref="T:System.Exception"/> that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner <see cref="T:System.Exception"/> is specified.</param>
        </member>
        <member name="P:Cqrs.Exceptions.MissingApplicationSettingException.AppSettingKey">
            <summary>
            The key of the app setting that is missing.
            </summary>
        </member>
        <member name="M:Cqrs.Exceptions.MissingApplicationSettingForConnectionStringException.#ctor(System.String)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Exceptions.MissingApplicationSettingException"/>.
            </summary>
            <param name="appSettingKey">The key of the app setting that is missing.</param>
        </member>
        <member name="M:Cqrs.Exceptions.MissingApplicationSettingForConnectionStringException.#ctor(System.String,System.Exception)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Exceptions.MissingApplicationSettingException"/> and a reference to the inner <paramref name="exception"/> that is the cause of this <see cref="T:System.Exception"/>.
            </summary>
            <param name="appSettingKey">The key of the app setting that is missing.</param>
            <param name="exception">The <see cref="T:System.Exception"/> that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner <see cref="T:System.Exception"/> is specified.</param>
        </member>
        <member name="T:Cqrs.Exceptions.MissingConnectionStringException">
            <summary>
            A <see cref="T:System.Configuration.ConnectionStringSettings"/> is missing from <see cref="P:System.Configuration.ConfigurationManager.ConnectionStrings"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Exceptions.MissingConnectionStringException.#ctor(System.String)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Exceptions.MissingConnectionStringException"/>.
            </summary>
            <param name="connectionStringName">The <see cref="P:System.Configuration.ConnectionStringSettings.Name"/> of the <see cref="T:System.Configuration.ConnectionStringSettings"/> that is missing.</param>
        </member>
        <member name="M:Cqrs.Exceptions.MissingConnectionStringException.#ctor(System.String,System.Exception)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Exceptions.MissingConnectionStringException"/> and a reference to the inner <paramref name="exception"/> that is the cause of this <see cref="T:System.Exception"/>.
            </summary>
            <param name="connectionStringName">The <see cref="P:System.Configuration.ConnectionStringSettings.Name"/> of the <see cref="T:System.Configuration.ConnectionStringSettings"/> that is missing.</param>
            <param name="exception">The <see cref="T:System.Exception"/> that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner <see cref="T:System.Exception"/> is specified.</param>
        </member>
        <member name="P:Cqrs.Exceptions.MissingConnectionStringException.ConnectionStringName">
            <summary>
            The <see cref="P:System.Configuration.ConnectionStringSettings.Name"/> of the <see cref="T:System.Configuration.ConnectionStringSettings"/> that is missing.
            </summary>
        </member>
        <member name="T:Cqrs.Hosts.CoreHost`1">
            <summary>
            Configure and start command and event handlers in a host
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CoreHost`1.#ctor">
            <summary>
            Instantiate a new instance of a <see cref="T:Cqrs.Hosts.CoreHost`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CoreHost`1.ConfigureTelemetry">
            <summary>
            When overridden, allows you to configure Telemetry
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CoreHost`1.Run(System.Action)">
            <summary>
            Calls <see cref="M:Cqrs.Hosts.CoreHost`1.Prepare"/>, <paramref name="handlerRegistation"/> and then <see cref="M:Cqrs.Hosts.CoreHost`1.Start"/>
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CoreHost`1.PrepareSecurityProtocol">
            <summary>
            Sets the <see cref="P:System.Net.ServicePointManager.SecurityProtocol"/> to <see cref="F:System.Net.SecurityProtocolType.Tls"/>.
            You might want to override this to .net 4.5 and above to SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CoreHost`1.Prepare">
            <summary>
            Prepare the host before registering handlers and starting the host.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CoreHost`1.ConfigureDefaultDependencyResolver">
            <summary>
            Configure the <see cref="T:Cqrs.Configuration.DependencyResolver"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CoreHost`1.Start">
            <summary>
            Start the host post preparing and registering handlers.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CoreHost`1.ManuallyRegisterEventHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event handler that will listen and respond to events.
            </summary>
            <param name="eventHandler">The event handler to call</param>
            <param name="holdMessageLock">If false, this will spin off another thread. This is a bad performance impact. Strongly suggest you use lock renewing instead... which is configuration based... so even better.</param>
        </member>
        <member name="M:Cqrs.Hosts.CoreHost`1.ManuallyRegisterCommandHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an command handler that will listen and respond to commands.
            </summary>
            <param name="commandHandler">The command handler to call</param>
            <param name="holdMessageLock">If false, this will spin off another thread. This is a bad performance impact. Strongly suggest you use lock renewing instead... which is configuration based... so even better.</param>
        </member>
        <member name="M:Cqrs.Hosts.CoreHost`1.StartBusRegistrar">
            <summary>
            Start the <see cref="T:Cqrs.Configuration.BusRegistrar"/> by calling <see cref="M:Cqrs.Configuration.BusRegistrar.Register(System.Type[])"/> passing <see cref="P:Cqrs.Hosts.CoreHost`1.HandlerTypes"/>
            </summary>
        </member>
        <member name="P:Cqrs.Hosts.CoreHost`1.ConfigurationManager">
            <summary>
            The <see cref="T:Cqrs.Configuration.IConfigurationManager"/> that can be use before the <see cref="P:Cqrs.Configuration.DependencyResolver.Current"/> is set.
            </summary>
        </member>
        <member name="P:Cqrs.Hosts.CoreHost`1.HandlerTypes">
            <summary>
            Each <see cref="T:System.Type"/> will be traced back to it's assembly, and that assembly will be scanned for other handlers to auto register.
            </summary>
        </member>
        <member name="P:Cqrs.Hosts.CoreHost`1.EventBus">
            <summary>
            The <see cref="T:Cqrs.Events.IEventReceiver"/> that will be configured to receive <see cref="T:Cqrs.Events.IEvent`1">events</see>.
            </summary>
        </member>
        <member name="P:Cqrs.Hosts.CoreHost`1.CommandBus">
            <summary>
            The <see cref="T:Cqrs.Commands.ICommandReceiver"/> that will be configured to receive <see cref="T:Cqrs.Commands.ICommand`1">commands</see>.
            </summary>
        </member>
        <member name="P:Cqrs.Hosts.CoreHost`1.TelemetryName">
            <summary>
            The hosts telemetry name if telemetry is configured
            </summary>
        </member>
        <member name="P:Cqrs.Hosts.CoreHost`1.CorrelationIdHelper">
            <summary>
            The <see cref="T:cdmdotnet.Logging.ICorrelationIdHelper"/> that will be used when starting and stopping the host.
            </summary>
        </member>
        <member name="P:Cqrs.Hosts.CoreHost`1.Logger">
            <summary>
            The <see cref="T:cdmdotnet.Logging.ILogger"/> that will be used when starting and stopping the host.
            </summary>
        </member>
        <member name="T:Cqrs.Hosts.CqrsHttpApplication">
            <summary>
            An <see cref="T:System.Web.HttpApplication"/> that prepares and configures CQRS with use in IIS or other web server.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.#ctor">
            <summary>
            Instantiate a new instance of a <see cref="T:Cqrs.Hosts.CqrsHttpApplication"/>
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.Application_Start(System.Object,System.EventArgs)">
            <summary>
            Calls <see cref="M:Cqrs.Hosts.CqrsHttpApplication.SetBuses"/>, <see cref="M:Cqrs.Hosts.CqrsHttpApplication.RegisterCommandAndEventHandlers"/>, <see cref="M:Cqrs.Hosts.CqrsHttpApplication.RegisterServiceParameterResolver"/>, <see cref="M:Cqrs.Hosts.CqrsHttpApplication.StartBuses"/> and finally <see cref="M:Cqrs.Hosts.CqrsHttpApplication.LogApplicationStarted"/>.
            Gets executed once during the life cycle of the application when the first request for any resource in the application is made. A resource can be a page or an image in the application. 
            If the server where the application is hosted is restarted then this is fired once again upon the first request for any resource in the application.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.SetBuses">
            <summary>
            Set <see cref="P:Cqrs.Hosts.CqrsHttpApplication.EventBus"/> and <see cref="P:Cqrs.Hosts.CqrsHttpApplication.CommandBus"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.RegisterCommandAndEventHandlers">
            <summary>
            Start the <see cref="T:Cqrs.Configuration.BusRegistrar"/> by calling <see cref="M:Cqrs.Configuration.BusRegistrar.Register(System.Type[])"/> passing <see cref="P:Cqrs.Hosts.CqrsHttpApplication.HandlerTypes"/>
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.RegisterServiceParameterResolver">
            <summary>
            Call the static "RegisterDataContracts" method on any <see cref="T:Cqrs.Services.IServiceParameterResolver"/> we can find in the <see cref="T:System.Reflection.Assembly"/> of any <see cref="T:System.Type"/> in <see cref="P:Cqrs.Hosts.CqrsHttpApplication.HandlerTypes"/>
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.StartBuses">
            <summary>
            Starts the command bus and event bus receivers depending on configuration settings
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.LogApplicationStarted">
            <summary>
            Log that the application has started
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.Application_End(System.Object,System.EventArgs)">
            <summary>
            Gets executed once during the life cycle of the application when it is unloaded.
            This is normally fired when the application is taken off-line or when the server is stopped.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.Application_Error(System.Object,System.EventArgs)">
            <summary>
            Logs all error via <see cref="M:cdmdotnet.Logging.ILogger.LogError(System.String,System.String,System.Exception,System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object})"/> unless the execution is <see cref="T:System.Security.SecurityException"/>, in which case <see cref="M:cdmdotnet.Logging.ILogger.LogWarning(System.String,System.String,System.Exception,System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object})"/> is used.
            Gets executed when any un-handled <see cref="T:System.Exception"/>/error occurs anywhere in the application. Any un-handled <see cref="T:System.Exception"/> here means exception which are not caught using try catch block. Also if you have custom errors enabled in your application i.e. in web.config file then the configuration in web.config takes precedence and all errors will be directed to the file mentioned in the tag.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.Application_BeginRequest(System.Object,System.EventArgs)">
            <summary>
            Gets executed for each and every request which comes to the application to generate a new CorrelationId and then sets the generated CorrelationId via <see cref="M:cdmdotnet.Logging.ICorrelationIdHelper.SetCorrelationId(System.Guid)"/>.
            The generated CorrelationId is also set in the <see cref="P:System.Web.HttpResponse.Headers"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.Application_EndRequest(System.Object,System.EventArgs)">
            <summary>
            Gets executed after <see cref="M:Cqrs.Hosts.CqrsHttpApplication.Application_BeginRequest(System.Object,System.EventArgs)"/> and before the stream starts getting sent to the client.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.Application_AuthenticateRequest(System.Object,System.EventArgs)">
            <summary>
            Gets executed after <see cref="M:Cqrs.Hosts.CqrsHttpApplication.Application_BeginRequest(System.Object,System.EventArgs)"/>.
            Override this method to extract any authentication token from the request and then call <see cref="M:Cqrs.Authentication.IAuthenticationTokenHelper`1.SetAuthenticationToken(`0)"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.Session_Start(System.Object,System.EventArgs)">
            <summary>
            Makes a call to retrieve the <see cref="P:System.Web.SessionState.HttpSessionState.SessionID"/>. This is done so the session is generated at the beginning of the request.
            If this isn't called the session (when using WCF) is generated late in the pipeline, which can cause issues when trying to work with WCF.
            Gets executed after <see cref="M:Cqrs.Hosts.CqrsHttpApplication.Application_AuthenticateRequest(System.Object,System.EventArgs)"/> when a new session for a "user" starts such as a first request or after a session has expired.
            This event doesn't get triggered if you are not using sessions which can be disabled in the web.config.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication.Session_End(System.Object,System.EventArgs)">
            <summary>
            Whenever a user's session in the application expires this gets executed. The session is no longer available or accessible. 
            The session expiration time can be set in web.config file. By default session time out is set to 20 mins.
            </summary>
        </member>
        <member name="P:Cqrs.Hosts.CqrsHttpApplication.HandlerTypes">
            <summary>
            Each <see cref="T:System.Type"/> will be traced back to it's assembly, and that assembly will be scanned for other handlers to auto register.
            </summary>
        </member>
        <member name="P:Cqrs.Hosts.CqrsHttpApplication.EventBus">
            <summary>
            The <see cref="T:Cqrs.Events.IEventReceiver"/> that will be configured to receive <see cref="T:Cqrs.Events.IEvent`1">events</see>.
            </summary>
        </member>
        <member name="P:Cqrs.Hosts.CqrsHttpApplication.CommandBus">
            <summary>
            The <see cref="T:Cqrs.Commands.ICommandReceiver"/> that will be configured to receive <see cref="T:Cqrs.Commands.ICommand`1">commands</see>.
            </summary>
        </member>
        <member name="T:Cqrs.Hosts.CqrsHttpApplication`1">
            <summary>
            An <see cref="T:System.Web.HttpApplication"/> that prepares and configures CQRS with use in IIS or other web server with knowledge of a basic type authentication token being sent in <see cref="P:System.Web.HttpRequest.Headers"/>, <see cref="P:System.Web.HttpRequest.Cookies"/>, <see cref="P:System.Web.HttpRequest.Form"/> or <see cref="P:System.Web.HttpRequest.QueryString"/>.
            A basic type authentication token is <see cref="T:System.Guid"/>, <see cref="T:System.String"/> or <see cref="T:System.Int32"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication`1.Application_AuthenticateRequest(System.Object,System.EventArgs)">
            <summary>
            Gets executed after <see cref="M:Cqrs.Hosts.CqrsHttpApplication.Application_BeginRequest(System.Object,System.EventArgs)"/>.
            Extracts the authentication token looking for a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> where the key as defined by the <see cref="P:System.Configuration.ConfigurationManager.AppSettings"/> "Cqrs.Web.AuthenticationTokenName",
            from the <see cref="P:System.Web.HttpRequest.Headers"/>, if one isn't found we then try the following in order 
            <see cref="P:System.Web.HttpRequest.Cookies"/>, <see cref="P:System.Web.HttpRequest.Form"/> or <see cref="P:System.Web.HttpRequest.QueryString"/>; then
            calls <see cref="M:Cqrs.Authentication.IAuthenticationTokenHelper`1.SetAuthenticationToken(`0)"/> to make it accessible to others parts of the system if one is found.
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.CqrsHttpApplication`1.SetBuses">
            <summary>
            Set <see cref="P:Cqrs.Hosts.CqrsHttpApplication.EventBus"/> and <see cref="P:Cqrs.Hosts.CqrsHttpApplication.CommandBus"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Hosts.StartUp">
            <summary>
            A startUp action for the <see cref="T:Cqrs.Hosts.CoreHost`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.StartUp.#ctor(System.Action)">
            <summary>
            Instantiate a new instance of a <see cref="T:Cqrs.Hosts.StartUp"/>
            </summary>
        </member>
        <member name="M:Cqrs.Hosts.StartUp.Initialise">
            <summary>
            Initialise by calling the <see cref="P:Cqrs.Hosts.StartUp.DependencyResolverConfigurationFunction"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Hosts.StartUp.DependencyResolverConfigurationFunction">
            <summary>
            The <see cref="T:System.Action"/> that will configure the <see cref="T:Cqrs.Configuration.DependencyResolver"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Infrastructure.SpinWait">
            <summary>
            Provides support for spin-based waiting.
            </summary>
        </member>
        <member name="F:Cqrs.Infrastructure.SpinWait.DefaultSleepInMilliseconds">
            <summary>
            A recommended sleep value of 50.
            </summary>
        </member>
        <member name="M:Cqrs.Infrastructure.SpinWait.SpinOnce(System.Int16)">
            <summary>
            Performs a single spin.
            </summary>
            <param name="sleepInMilliseconds">The amount of milliseconds the thread will sleep for.</param>
        </member>
        <member name="M:Cqrs.Infrastructure.SpinWait.Reset">
            <summary>
            Resets the spin counter.
            </summary>
        </member>
        <member name="M:Cqrs.Infrastructure.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int16)">
            <summary>
            Spins until the specified condition is satisfied.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="sleepInMilliseconds">The amount of milliseconds the thread will sleep for.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
        </member>
        <member name="M:Cqrs.Infrastructure.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan,System.Int16)">
            <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
            
            <returns>
            True if the condition is satisfied within the timeout; otherwise, false
            </returns>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="sleepInMilliseconds">The amount of milliseconds the thread will sleep for.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:Cqrs.Infrastructure.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32,System.Int16)">
            <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
            
            <returns>
            True if the condition is satisfied within the timeout; otherwise, false
            </returns>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="sleepInMilliseconds">The amount of milliseconds the thread will sleep for.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="P:Cqrs.Infrastructure.SpinWait.NextSpinWillYield">
            <summary>
            Gets whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce"/> will yield the processor, triggering a forced context switch.
            </summary>
            
            <returns>
            Whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce"/> will yield the processor, triggering a forced context switch.
            </returns>
        </member>
        <member name="M:Cqrs.Infrastructure.SpinWait.TimeoutHelper.GetTime">
            <summary>
            Gets the number of milliseconds elapsed since the system started.
            </summary>
        </member>
        <member name="M:Cqrs.Infrastructure.SpinWait.TimeoutHelper.UpdateTimeOut(System.UInt32,System.Int32)">
            <summary>
            Does some interesting maths.
            </summary>
        </member>
        <member name="T:Cqrs.Messages.FrameworkType">
            <summary>
            Indicates a framework system or type.
            </summary>
        </member>
        <member name="F:Cqrs.Messages.FrameworkType.Unknown">
            <summary>
            An unknown framework.
            </summary>
        </member>
        <member name="F:Cqrs.Messages.FrameworkType.External">
            <summary>
            An external framework.
            </summary>
        </member>
        <member name="F:Cqrs.Messages.FrameworkType.BuiltIn">
            <summary>
            The built-in framework
            </summary>
        </member>
        <member name="F:Cqrs.Messages.FrameworkType.Akka">
            <summary>
            The CQRS Akka.NET framework
            </summary>
        </member>
        <member name="T:Cqrs.Messages.ITelemeteredMessage">
            <summary>
            A message that can allows you to manually inform the telemetry system it's name.
            </summary>
        </member>
        <member name="P:Cqrs.Messages.ITelemeteredMessage.TelemetryName">
            <summary>
            Gets or sets the Name of this message.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.InMemoryDatabase">
            <summary>
            Uses a static <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> to store data accessible by all threads.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.Get``1">
            <summary>
            Gets all instances of the specific <typeparamref name="TEntity"/> grouped by their ID.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.GetAll``1">
            <summary>
            Gets all instances of the specific <typeparamref name="TEntity"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.#ctor(System.Collections.Generic.IDictionary{System.Guid,`0})">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Add(`0)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. </exception>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
            <returns>
            true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="array"/> is multidimensional.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"/> is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>.-or-Type <typeparamref name="TEntity"/> cannot be cast automatically to the type of the destination <paramref name="array"/>.</exception>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <returns>
            The index of <paramref name="item"/> if found in the list; otherwise, -1.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param><param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1"/> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="P:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
            </returns>
        </member>
        <member name="P:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <returns>
            The element at the specified index.
            </returns>
            <param name="index">The zero-based index of the element to get or set.</param><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="T:Cqrs.Repositories.IRepository`2">
            <summary>
            Provides basic repository methods for operations with an <see cref="T:Cqrs.DataStores.IDataStore`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.IRepository`2.Create(`1)">
            <summary>
            Create the newly provided <paramref name="data"/> to storage.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.IRepository`2.Create(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Create the newly provided <paramref name="data"/> to storage.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.IRepository`2.Retrieve(Cqrs.Repositories.Queries.ISingleResultQuery{`0,`1},System.Boolean)">
            <summary>
            Builds and executes the provided <paramref name="singleResultQuery"/>.
            </summary>
            <param name="singleResultQuery">The <see cref="T:Cqrs.Repositories.Queries.ISingleResultQuery`2"/> to build and execute.</param>
            <param name="throwExceptionWhenNoQueryResults">If true will throw an <see cref="T:System.Exception"/> if no data is found in storage.</param>
        </member>
        <member name="M:Cqrs.Repositories.IRepository`2.Retrieve(Cqrs.Repositories.Queries.ICollectionResultQuery{`0,`1})">
            <summary>
            Builds and executes the provided <paramref name="resultQuery"/>.
            </summary>
            <param name="resultQuery">The <see cref="T:Cqrs.Repositories.Queries.ICollectionResultQuery`2"/> to build and execute.</param>
        </member>
        <member name="M:Cqrs.Repositories.IRepository`2.Update(`1)">
            <summary>
            Update the provided <paramref name="data"/> in storage.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.IRepository`2.Delete(`1)">
            <summary>
            Will mark the <paramref name="data"/> as logically (or soft).
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.IRepository`2.DeleteAll">
            <summary>
            Delete all contents (normally by use of a truncate operation) in storage.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.IRepository`2.Destroy(`1)">
            <summary>
            Remove the provided <paramref name="data"/> from storage.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.IRepository`2.Load(System.Guid,System.Boolean)">
            <summary>
            Load the <typeparamref name="TData"/> from storage identified by the provided <paramref name="rsn"/>.
            </summary>
            <param name="rsn">The identifier if the <typeparamref name="TData"/> to load.</param>
            <param name="throwExceptionOnMissingEntity">If true will throw an <see cref="T:System.Exception"/> if no data is found in storage.</param>
        </member>
        <member name="T:Cqrs.Repositories.Queries.AndQueryPredicate">
            <summary>
            An <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/> where both the <see cref="P:Cqrs.Repositories.Queries.AndQueryPredicate.LeftQueryPredicate"/> and the <see cref="P:Cqrs.Repositories.Queries.AndQueryPredicate.RightQueryPredicate"/> must evaluate to true.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.IAndQueryPredicate">
            <summary>
            An <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/> where both the <see cref="P:Cqrs.Repositories.Queries.IAndQueryPredicate.LeftQueryPredicate"/> and the <see cref="P:Cqrs.Repositories.Queries.IAndQueryPredicate.RightQueryPredicate"/> must evaluate to true.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.IQueryPredicate">
            <summary>
            A predicate used in queries, similar to a filter and/order statement.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.IAndQueryPredicate.LeftQueryPredicate">
            <summary>
            The left side <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.IAndQueryPredicate.RightQueryPredicate">
            <summary>
            The right side <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.AndQueryPredicate.LeftQueryPredicate">
            <summary>
            The left side <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.AndQueryPredicate.RightQueryPredicate">
            <summary>
            The right side <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.CollectionResultQuery`2">
            <summary>
            A query that will produce a result that contains a collection of <typeparamref name="TData"/> items.
            </summary>
            <typeparam name="TQueryStrategy">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type"/> of data in the result collection.</typeparam>
        </member>
        <member name="T:Cqrs.Repositories.Queries.ResultQuery`2">
            <summary>
            A query that will produce a result
            </summary>
            <typeparam name="TQueryStrategy">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type"/> of data in the result collection.</typeparam>
        </member>
        <member name="T:Cqrs.Repositories.Queries.IQueryWithStrategy`1">
            <summary>
            A query that utilises a <typeparamref name="TQueryStrategy"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.IQueryWithStrategy`1.QueryStrategy">
            <summary>
            The <typeparamref name="TQueryStrategy"/> to be executed and produce a result.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.IQueryWithResults`1">
            <summary>
            A query that will produce a result
            </summary>
            <typeparam name="TResult">The <see cref="T:System.Type"/> of data in the result collection.</typeparam>
        </member>
        <member name="P:Cqrs.Repositories.Queries.IQueryWithResults`1.Result">
            <summary>
            The resulting of executing the <see cref="T:Cqrs.Repositories.Queries.QueryStrategy"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.ResultQuery`2.QueryStrategy">
            <summary>
            The <typeparamref name="TQueryStrategy"/> to be executed and produce a result.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.ResultQuery`2.Result">
            <summary>
            The resulting of executing the <see cref="P:Cqrs.Repositories.Queries.ResultQuery`2.QueryStrategy"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.ICollectionResultQuery`2">
            <summary>
            A query that will produce a result that contains a collection of <typeparamref name="TData"/> items.
            </summary>
            <typeparam name="TQueryStrategy">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type"/> of data in the result collection.</typeparam>
        </member>
        <member name="T:Cqrs.Repositories.Queries.IOrQueryPredicate">
            <summary>
            An <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/> where either the <see cref="P:Cqrs.Repositories.Queries.IOrQueryPredicate.LeftQueryPredicate"/> or the <see cref="P:Cqrs.Repositories.Queries.IOrQueryPredicate.RightQueryPredicate"/> must evaluate to true.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.IOrQueryPredicate.LeftQueryPredicate">
            <summary>
            The left side <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.IOrQueryPredicate.RightQueryPredicate">
            <summary>
            The right side <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.IQueryBuilder`2">
            <summary>
            Builds an <see cref="T:System.Linq.IQueryable"/> from a <typeparamref name="TQueryStrategy"/>.
            </summary>
            <typeparam name="TQueryStrategy">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type"/> of data to query.</typeparam>
        </member>
        <member name="M:Cqrs.Repositories.Queries.IQueryBuilder`2.CreateQueryable(Cqrs.Repositories.Queries.ISingleResultQuery{`0,`1})">
            <summary>
            Create an <see cref="T:System.Linq.IQueryable"/> of <typeparamref name="TData"/>
            that expects a single <typeparamref name="TData"/> item.
            </summary>
            <param name="singleResultQuery">The query.</param>
        </member>
        <member name="M:Cqrs.Repositories.Queries.IQueryBuilder`2.CreateQueryable(Cqrs.Repositories.Queries.ICollectionResultQuery{`0,`1})">
            <summary>
            Create an <see cref="T:System.Linq.IQueryable"/> of <typeparamref name="TData"/>
            that expects a collection of <typeparamref name="TData"/> items.
            </summary>
            <param name="collectionResultQuery">The query.</param>
        </member>
        <member name="T:Cqrs.Repositories.Queries.IQueryFactory">
            <summary>
            A factory to create new instances of <see cref="T:Cqrs.Repositories.Queries.ResultQuery`2"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.IQueryFactory.CreateNewSingleResultQuery``2">
            <summary>
            Creates a new <see cref="T:Cqrs.Repositories.Queries.ISingleResultQuery`2"/>
            </summary>
            <typeparam name="TUserQueryStrategy">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/> it will use.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type"/> of data the <see cref="T:Cqrs.Repositories.Queries.ISingleResultQuery`2"/> will operate on.</typeparam>
        </member>
        <member name="M:Cqrs.Repositories.Queries.IQueryFactory.CreateNewCollectionResultQuery``2">
            <summary>
            Creates a new <see cref="T:Cqrs.Repositories.Queries.ICollectionResultQuery`2"/>
            </summary>
            <typeparam name="TUserQueryStrategy">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/> it will use.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type"/> of data the <see cref="T:Cqrs.Repositories.Queries.ISingleResultQuery`2"/> will operate on.</typeparam>
        </member>
        <member name="T:Cqrs.Repositories.Queries.IQueryPredicateData">
            <summary>
            Information about a query.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.IQueryPredicateData.Name">
            <summary>
            The Name of the function in the <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.IQueryPredicateData.Parameters">
            <summary>
            The parameters passed to the function in the <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.IQueryStrategy">
            <summary>
            A specification for a query to execute.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.IQueryStrategy.QueryPredicate">
            <summary>
            The predicate that will be evaluated.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.ISingleResultQuery`2">
            <summary>
            A query that will produce a result that is a single <typeparamref name="TData"/> item.
            </summary>
            <typeparam name="TQueryStrategy">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type"/> of result data.</typeparam>
        </member>
        <member name="T:Cqrs.Repositories.Queries.OrQueryPredicate">
            <summary>
            An <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/> where either the <see cref="P:Cqrs.Repositories.Queries.OrQueryPredicate.LeftQueryPredicate"/> or the <see cref="P:Cqrs.Repositories.Queries.OrQueryPredicate.RightQueryPredicate"/> must evaluate to true.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.OrQueryPredicate.LeftQueryPredicate">
            <summary>
            The left side <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.OrQueryPredicate.RightQueryPredicate">
            <summary>
            The right side <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.QueryBuilder`2">
            <summary>
            Builds an <see cref="T:System.Linq.IQueryable"/> from a <typeparamref name="TQueryStrategy"/>.
            </summary>
            <typeparam name="TQueryStrategy">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type"/> of data to query.</typeparam>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.#ctor(Cqrs.DataStores.IDataStore{`1},Cqrs.Configuration.IDependencyResolver)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Repositories.Queries.QueryBuilder`2"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.CreateQueryable(Cqrs.Repositories.Queries.ISingleResultQuery{`0,`1})">
            <summary>
            Create an <see cref="T:System.Linq.IQueryable"/> of <typeparamref name="TData"/>
            that expects a single <typeparamref name="TData"/> item.
            </summary>
            <param name="singleResultQuery">The query.</param>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.CreateQueryable(Cqrs.Repositories.Queries.ICollectionResultQuery{`0,`1})">
            <summary>
            Create an <see cref="T:System.Linq.IQueryable"/> of <typeparamref name="TData"/>
            that expects a collection of <typeparamref name="TData"/> items.
            </summary>
            <param name="collectionResultQuery">The query.</param>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetEmptyQueryPredicate">
            <summary>
            Returns the <see cref="P:Cqrs.Repositories.Queries.QueryBuilder`2.DataStore"/> itself.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GeneratePredicate(Cqrs.Repositories.Queries.IQueryPredicate,System.Linq.IQueryable{`1})">
            <summary>
            Builds an <see cref="T:System.Linq.IQueryable"/> from the <paramref name="queryPredicate"/> and an optional <paramref name="leftHandQueryable"/>.
            This recursively calls itself and may call <see cref="M:Cqrs.Repositories.Queries.QueryBuilder`2.GeneratePredicateIsNotLogicallyDeleted(Cqrs.Repositories.Queries.QueryPredicate,System.Linq.IQueryable{`1})"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GeneratePredicateIsNotLogicallyDeleted(Cqrs.Repositories.Queries.QueryPredicate,System.Linq.IQueryable{`1})">
            <summary>
            Builds the relevant <see cref="T:System.Linq.IQueryable"/> for <see cref="M:Cqrs.Repositories.Queries.QueryStrategy.IsNotLogicallyDeleted"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GeneratePredicateWithPermissionScopeAny``1(Cqrs.Repositories.Queries.QueryPredicate,System.Linq.IQueryable{`1})">
            <summary>
            Builds the relevant <see cref="T:System.Linq.IQueryable"/> for <see cref="M:Cqrs.Repositories.Queries.QueryStrategy.WithPermissionScopeAny``1(``0)"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.OnGeneratePredicateWithPermissionScopeAny``1(Cqrs.Repositories.Queries.QueryPredicate,System.Linq.IQueryable{`1})">
            <summary>
            Returns <paramref name="leftHandQueryable"/> or calls <see cref="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetEmptyQueryPredicate"/> if <paramref name="leftHandQueryable"/> is null.
            Override to build the relevant permission scope <see cref="T:System.Linq.IQueryable"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GeneratePredicateWithPermissionScopeUser``1(Cqrs.Repositories.Queries.QueryPredicate,System.Linq.IQueryable{`1})">
            <summary>
            Builds the relevant <see cref="T:System.Linq.IQueryable"/> for <see cref="M:Cqrs.Repositories.Queries.QueryStrategy.WithPermissionScopeUser``1(``0)"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.OnGeneratePredicateWithPermissionScopeUser``1(Cqrs.Repositories.Queries.QueryPredicate,System.Linq.IQueryable{`1})">
            <summary>
            Returns <paramref name="leftHandQueryable"/> or calls <see cref="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetEmptyQueryPredicate"/> if <paramref name="leftHandQueryable"/> is null.
            Override to build the relevant permission scope <see cref="T:System.Linq.IQueryable"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GeneratePredicateWithPermissionScopeCompany``1(Cqrs.Repositories.Queries.QueryPredicate,System.Linq.IQueryable{`1})">
            <summary>
            Builds the relevant <see cref="T:System.Linq.IQueryable"/> for <see cref="M:Cqrs.Repositories.Queries.QueryStrategy.WithPermissionScopeCompany``1(``0)"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.OnGeneratePredicateWithPermissionScopeCompany``1(Cqrs.Repositories.Queries.QueryPredicate,System.Linq.IQueryable{`1})">
            <summary>
            Returns <paramref name="leftHandQueryable"/> or calls <see cref="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetEmptyQueryPredicate"/> if <paramref name="leftHandQueryable"/> is null.
            Override to build the relevant permission scope <see cref="T:System.Linq.IQueryable"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GeneratePredicateWithPermissionScopeCompanyAndUser``1(Cqrs.Repositories.Queries.QueryPredicate,System.Linq.IQueryable{`1})">
            <summary>
            Builds the relevant <see cref="T:System.Linq.IQueryable"/> for <see cref="M:Cqrs.Repositories.Queries.QueryStrategy.WithPermissionScopeCompanyAndUser``1(``0)"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.OnGeneratePredicateWithPermissionScopeCompanyAndUser``1(Cqrs.Repositories.Queries.QueryPredicate,System.Linq.IQueryable{`1})">
            <summary>
            Returns <paramref name="leftHandQueryable"/> or calls <see cref="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetEmptyQueryPredicate"/> if <paramref name="leftHandQueryable"/> is null.
            Override to build the relevant permission scope <see cref="T:System.Linq.IQueryable"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GeneratePredicate(Cqrs.Repositories.Queries.QueryPredicate,System.Linq.IQueryable{`1})">
            <summary>
            Override to build an <see cref="T:System.Linq.IQueryable"/> from the <paramref name="queryPredicate"/> and an optional <paramref name="leftHandQueryable"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetFunctionNameOfType``1(System.Func{``0,Cqrs.Repositories.Queries.IQueryPredicate})">
            <summary>
            Gets the Name of the method in <paramref name="expression"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetFunctionName``1(System.Func{``0})">
            <summary>
            Gets the Name of the method in <paramref name="expression"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetFunctionName``1(System.Func{``0,`0})">
            <summary>
            Gets the Name of the method in <paramref name="expression"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetFunctionName``2(System.Func{``0,``1,`0})">
            <summary>
            Gets the Name of the method in <paramref name="expression"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetFunctionName``3(System.Func{``0,``1,``2,`0})">
            <summary>
            Gets the Name of the method in <paramref name="expression"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetFunctionName``4(System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Gets the Name of the method in <paramref name="expression"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetFunctionName``5(System.Func{``0,``1,``2,``3,``4,`0})">
            <summary>
            Gets the Name of the method in <paramref name="expression"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.GetNullQueryStrategy">
            <summary>
            Uses <see cref="M:System.Activator.CreateInstance``1"/> to create a new instance of <typeparamref name="TQueryStrategy"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryBuilder`2.ApplySorting(`0,System.Linq.IQueryable{`1}@)">
            <summary>
            Override to build or apply any sorting required to <paramref name="queryable"/>
            </summary>
            <param name="queryStrategy">The <typeparamref name="TQueryStrategy"/> with sorting information.</param>
            <param name="queryable">The <see cref="T:System.Linq.IQueryable"/> to apply sorting to.</param>
        </member>
        <member name="P:Cqrs.Repositories.Queries.QueryBuilder`2.DataStore">
            <summary>
            Gets or set the <see cref="T:Cqrs.DataStores.IDataStore`1"/> to use.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.QueryBuilder`2.DependencyResolver">
            <summary>
            Gets or set the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.QueryFactory">
            <summary>
            A factory to create new instances of <see cref="T:Cqrs.Repositories.Queries.ResultQuery`2"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryFactory.#ctor(Cqrs.Configuration.IDependencyResolver)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Repositories.Queries.QueryFactory"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryFactory.CreateNewSingleResultQuery``2">
            <summary>
            Creates a new <see cref="T:Cqrs.Repositories.Queries.ISingleResultQuery`2"/>
            using <see cref="P:Cqrs.Repositories.Queries.QueryFactory.DependencyResolver"/> to create a new <typeparamref name="TUserQueryStrategy"/>.
            </summary>
            <typeparam name="TUserQueryStrategy">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/> it will use.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type"/> of data the <see cref="T:Cqrs.Repositories.Queries.ISingleResultQuery`2"/> will operate on.</typeparam>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryFactory.CreateNewCollectionResultQuery``2">
            <summary>
            Creates a new <see cref="T:Cqrs.Repositories.Queries.ICollectionResultQuery`2"/>
            using <see cref="P:Cqrs.Repositories.Queries.QueryFactory.DependencyResolver"/> to create a new <typeparamref name="TUserQueryStrategy"/>.
            </summary>
            <typeparam name="TUserQueryStrategy">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/> it will use.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type"/> of data the <see cref="T:Cqrs.Repositories.Queries.ISingleResultQuery`2"/> will operate on.</typeparam>
        </member>
        <member name="P:Cqrs.Repositories.Queries.QueryFactory.DependencyResolver">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.QueryParameter">
            <summary>
            Information about a parameter pass to a function in a <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryParameter.#ctor">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Repositories.Queries.QueryParameter"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryParameter.#ctor(System.String,System.Object)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Repositories.Queries.QueryParameter"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryParameter.GetParameterValue``1">
            <summary>
            Returns <see cref="P:Cqrs.Repositories.Queries.QueryParameter.ParameterValue"/> cast to <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryParameter.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
            <returns>
            A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than <paramref name="obj"/>. Zero This instance is equal to <paramref name="obj"/>. Greater than zero This instance is greater than <paramref name="obj"/>. 
            </returns>
            <param name="obj">An object to compare with this instance. </param>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is not the same type as this instance. </exception>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryParameter.CompareTo(Cqrs.Repositories.Queries.QueryParameter)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A value that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other"/> parameter.Zero This object is equal to <paramref name="other"/>. Greater than zero This object is greater than <paramref name="other"/>. 
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="P:Cqrs.Repositories.Queries.QueryParameter.ParameterName">
            <summary>
            The name of the parameter.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.QueryParameter.ParameterValue">
            <summary>
            The value of the parameter.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.QueryPredicate">
            <summary>
            Information about a query.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryPredicate.#ctor">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Repositories.Queries.QueryPredicate"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.QueryPredicate.Name">
            <summary>
            The Name of the function in the <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.QueryPredicate.Parameters">
            <summary>
            The parameters passed to function in the <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.QueryPredicateExtensions">
            <summary>
            A collection of extension methods for working with queries.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryPredicateExtensions.GetValue``1(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Gets the value from the provided <paramref name="keyValuePair"/> cast to <typeparamref name="TResult"/>.
            </summary>
            <remarks>
            Gets the <see cref="P:System.Collections.Generic.KeyValuePair`2.Value"/> from the provided <paramref name="keyValuePair"/> cast to <typeparamref name="TResult"/>.
            </remarks>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryPredicateExtensions.GetValue``1(System.Collections.Generic.ISet{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.String)">
            <summary>
            Gets the value from the provided <paramref name="collection"/> cast to <typeparamref name="TResult"/>.
            </summary>
            <remarks>
            Filters the provided <paramref name="collection"/> where the <see cref="P:System.Collections.Generic.KeyValuePair`2.Key"/> equals the provided <paramref name="key"/>
            then gets the <see cref="P:System.Collections.Generic.KeyValuePair`2.Value"/> cast to <typeparamref name="TResult"/>.
            </remarks>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryPredicateExtensions.GetValue``1(System.Collections.Generic.SortedSet{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.Int32)">
            <summary>
            Gets the value from the provided <paramref name="collection"/> cast to <typeparamref name="TResult"/>.
            </summary>
            <remarks>
            Gets the <see cref="T:System.Collections.Generic.KeyValuePair`2"/> at index <paramref name="index"/> from the provided <paramref name="collection"/>
            then gets the <see cref="P:System.Collections.Generic.KeyValuePair`2.Value"/> cast to <typeparamref name="TResult"/>.
            </remarks>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryPredicateExtensions.GetValue``1(Cqrs.Repositories.Queries.QueryParameter)">
            <summary>
            Gets the value from the provided <paramref name="queryParameter"/> cast to <typeparamref name="TResult"/>.
            </summary>
            <remarks>
            Gets the <see cref="P:Cqrs.Repositories.Queries.QueryParameter.ParameterValue"/> cast to <typeparamref name="TResult"/>.
            </remarks>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryPredicateExtensions.GetValue``1(System.Collections.Generic.ISet{Cqrs.Repositories.Queries.QueryParameter},System.String)">
            <summary>
            Gets the value from the provided <paramref name="collection"/> cast to <typeparamref name="TResult"/>.
            </summary>
            <remarks>
            Filters the provided <paramref name="collection"/> where the <see cref="P:Cqrs.Repositories.Queries.QueryParameter.ParameterName"/> equals the provided <paramref name="parameterName"/>
            then gets the <see cref="P:Cqrs.Repositories.Queries.QueryParameter.ParameterValue"/> cast to <typeparamref name="TResult"/>.
            </remarks>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryPredicateExtensions.GetValue``1(System.Collections.Generic.SortedSet{Cqrs.Repositories.Queries.QueryParameter},System.Int32)">
            <summary>
            Gets the value from the provided <paramref name="collection"/> cast to <typeparamref name="TResult"/>.
            </summary>
            <remarks>
            Gets the <see cref="T:Cqrs.Repositories.Queries.QueryParameter"/> at index <paramref name="index"/> from the provided <paramref name="collection"/>
            then gets the <see cref="P:Cqrs.Repositories.Queries.QueryParameter.ParameterValue"/> cast to <typeparamref name="TResult"/>.
            </remarks>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryPredicateExtensions.GetValue``1(System.Collections.Generic.SortedSet{Cqrs.Repositories.Queries.QueryParameter},System.String)">
            <summary>
            Gets the value from the provided <paramref name="collection"/> cast to <typeparamref name="TResult"/>.
            </summary>
            <remarks>
            Filters the provided <paramref name="collection"/> where the <see cref="P:Cqrs.Repositories.Queries.QueryParameter.ParameterName"/> equals the provided <paramref name="parameterName"/>
            then gets the <see cref="P:Cqrs.Repositories.Queries.QueryParameter.ParameterValue"/> cast to <typeparamref name="TResult"/>.
            </remarks>
        </member>
        <member name="T:Cqrs.Repositories.Queries.QueryStrategy">
            <summary>
            A specification for a query to execute.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryStrategy.IsNotLogicallyDeleted">
            <summary>
            Filter to all items not logically deleted.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryStrategy.WithPermissionScopeAny``1(``0)">
            <summary>
            Filter to all items with any permission scope.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryStrategy.WithPermissionScopeUser``1(``0)">
            <summary>
            Filter to any items the authenticated user can view.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryStrategy.WithPermissionScopeCompany``1(``0)">
            <summary>
            Filter to any items the company the authenticated user can view.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryStrategy.WithPermissionScopeCompanyAndUser``1(``0)">
            <summary>
            Filter to any items the company the authenticated user can view and then filter the results to any items the authenticated user can see.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryStrategy.BuildQueryPredicate``1(System.Func{``0})">
            <summary>
            Builds a <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/> from the provided <paramref name="func"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryStrategy.BuildQueryPredicate``2(System.Func{``0,``1},``0)">
            <summary>
            Builds a <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/> from the provided <paramref name="func"/>
            storing the provided <paramref name="parameter1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryStrategy.BuildQueryPredicate``3(System.Func{``0,``1,``2},``0,``1)">
            <summary>
            Builds a <see cref="T:Cqrs.Repositories.Queries.IQueryPredicate"/> from the provided <paramref name="func"/>
            storing the provided <paramref name="parameter1"/> and <paramref name="parameter2"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryStrategy.And(Cqrs.Repositories.Queries.IQueryPredicate)">
            <summary>
            Builds an <see cref="T:Cqrs.Repositories.Queries.IAndQueryPredicate"/> between <see cref="P:Cqrs.Repositories.Queries.QueryStrategy.QueryPredicate"/>
            and the provided <paramref name="queryPredicate"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Queries.QueryStrategy.Or(Cqrs.Repositories.Queries.IQueryPredicate)">
            <summary>
            Builds an <see cref="T:Cqrs.Repositories.Queries.IOrQueryPredicate"/> between <see cref="P:Cqrs.Repositories.Queries.QueryStrategy.QueryPredicate"/>
            and the provided <paramref name="queryPredicate"/>
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.QueryStrategy.QueryPredicate">
            <summary>
            The predicate that will be evaluated.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.SingleResultQuery`2">
            <summary>
            A query that will produce a result that is a single <typeparamref name="TData"/> item.
            </summary>
            <typeparam name="TQueryStrategy">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type"/> of result data.</typeparam>
        </member>
        <member name="T:Cqrs.Repositories.Queries.SortParameter`1">
            <summary>
            Sorting information.
            </summary>
            <typeparam name="TSortBy">The <see cref="T:System.Type"/> to sort by</typeparam>.
        </member>
        <member name="P:Cqrs.Repositories.Queries.SortParameter`1.SortBy">
            <summary>
            What to sort by.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Queries.SortParameter`1.Direction">
            <summary>
            The direction to sort.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Queries.SortParameter`1.SortParameterDirectionType">
            <summary>
            Sort direction.
            </summary>
        </member>
        <member name="F:Cqrs.Repositories.Queries.SortParameter`1.SortParameterDirectionType.Ascending">
            <summary>
            Sort Ascending.
            </summary>
        </member>
        <member name="F:Cqrs.Repositories.Queries.SortParameter`1.SortParameterDirectionType.Descending">
            <summary>
            Sort Descending.
            </summary>
        </member>
        <member name="T:Cqrs.Repositories.Repository`3">
            <summary>
            Provides basic repository methods for operations with an <see cref="T:Cqrs.DataStores.IDataStore`1"/>.
            </summary>
            <typeparam name="TQueryStrategy">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Repositories.Queries.IQueryStrategy"/>.</typeparam>
            <typeparam name="TQueryBuilder">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Repositories.Queries.QueryBuilder`2"/> that will be used to build queries.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type"/> of data held in storage.</typeparam>
        </member>
        <member name="M:Cqrs.Repositories.Repository`3.#ctor(System.Func{Cqrs.DataStores.IDataStore{`2}},`1)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Repositories.Repository`3"/>
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Repository`3.Create(`2)">
            <summary>
            Create the newly provided <paramref name="data"/> to storage.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Repository`3.Create(System.Collections.Generic.IEnumerable{`2})">
            <summary>
            Create the newly provided <paramref name="data"/> to storage.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Repository`3.Retrieve(Cqrs.Repositories.Queries.ISingleResultQuery{`0,`2},System.Boolean)">
            <summary>
            Builds and executes the provided <paramref name="singleResultQuery"/>.
            </summary>
            <param name="singleResultQuery">The <see cref="T:Cqrs.Repositories.Queries.ISingleResultQuery`2"/> to build and execute.</param>
            <param name="throwExceptionWhenNoQueryResults">If true will throw an <see cref="T:System.Exception"/> if no data is found in storage.</param>
        </member>
        <member name="M:Cqrs.Repositories.Repository`3.Retrieve(Cqrs.Repositories.Queries.ICollectionResultQuery{`0,`2})">
            <summary>
            Builds and executes the provided <paramref name="resultQuery"/>.
            </summary>
            <param name="resultQuery">The <see cref="T:Cqrs.Repositories.Queries.ICollectionResultQuery`2"/> to build and execute.</param>
        </member>
        <member name="M:Cqrs.Repositories.Repository`3.Update(`2)">
            <summary>
            Update the provided <paramref name="data"/> in storage.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Repository`3.Delete(`2)">
            <summary>
            Will mark the <paramref name="data"/> as logically (or soft).
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Repository`3.DeleteAll">
            <summary>
            Delete all contents (normally by use of a truncate operation) in storage.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Repository`3.Destroy(`2)">
            <summary>
            Remove the provided <paramref name="data"/> from storage.
            </summary>
        </member>
        <member name="M:Cqrs.Repositories.Repository`3.Load(System.Guid,System.Boolean)">
            <summary>
            Load the <typeparamref name="TData"/> from storage identified by the provided <paramref name="rsn"/>.
            </summary>
            <param name="rsn">The identifier if the <typeparamref name="TData"/> to load.</param>
            <param name="throwExceptionOnMissingEntity">If true will throw an <see cref="T:System.Exception"/> if no data is found in storage.</param>
        </member>
        <member name="M:Cqrs.Repositories.Repository`3.CreateQueryable(System.Linq.Expressions.Expression{System.Func{`2,System.Boolean}})">
            <summary>
            Calls <see cref="P:Cqrs.Repositories.Repository`3.CreateDataStoreFunction"/> passing the <paramref name="predicate"/>.
            </summary>
            <param name="predicate">A function defining a filter if required.</param>
        </member>
        <member name="P:Cqrs.Repositories.Repository`3.CreateDataStoreFunction">
            <summary>
            Gets or sets the <see cref="T:System.Func`1"/> that is used to create new instances of <see cref="T:Cqrs.DataStores.IDataStore`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Repository`3.QueryBuilder">
            <summary>
            Gets or sets the <typeparamref name="TQueryBuilder"/> that will be used to build queries.
            </summary>
        </member>
        <member name="P:Cqrs.Repositories.Repository`3.TelemetryHelper">
            <summary>
            Gets or sets the <see cref="T:cdmdotnet.Logging.ITelemetryHelper"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Services.BasicServiceParameterResolver`2">
            <summary>
            A <see cref="T:System.Runtime.Serialization.DataContractResolver"/> for use via WCF that ensures basic support for 
            <see cref="T:Cqrs.Services.ServiceResponse"/>, <see cref="T:Cqrs.Services.ServiceRequest`1"/>
            and anything <see cref="P:Cqrs.Services.BasicServiceParameterResolver`2.TokenResolver"/> and <see cref="P:Cqrs.Services.BasicServiceParameterResolver`2.EventDataResolver"/> support.
            </summary>
            <typeparam name="TServiceParameter">The <see cref="T:System.Type"/> of the service to include in the <see cref="P:Cqrs.Services.BasicServiceParameterResolver`2.ServiceNamespace"/>.</typeparam>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Services.BasicServiceParameterResolver`2.#ctor(Cqrs.Services.ISingleSignOnTokenResolver,Cqrs.Services.IEventDataResolver)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Services.BasicServiceParameterResolver`2"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Services.BasicServiceParameterResolver`2.#ctor(Cqrs.Services.IEventDataResolver)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Services.BasicServiceParameterResolver`2"/>
            defaulting <see cref="P:Cqrs.Services.BasicServiceParameterResolver`2.TokenResolver"/> to <see cref="T:Cqrs.Authentication.BasicTokenResolver"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Services.BasicServiceParameterResolver`2.TryResolveType(System.Type,System.Type,System.Runtime.Serialization.DataContractResolver,System.Xml.XmlDictionaryString@,System.Xml.XmlDictionaryString@)">
            <summary>
            Maps a data contract type to an xsi:type name and namespace during serialization.
            </summary>
            <param name="dataContractType">The type to map.</param>
            <param name="declaredType">The type declared in the data contract.</param>
            <param name="knownTypeResolver">The known type resolver.</param>
            <param name="typeName">The xsi:type name.</param>
            <param name="typeNamespace">The xsi:type namespace.</param>
            <returns>true if mapping succeeded; otherwise, false.</returns>
        </member>
        <member name="M:Cqrs.Services.BasicServiceParameterResolver`2.TryResolveUnResolvedType(System.Type,System.Type,System.Runtime.Serialization.DataContractResolver,System.Xml.XmlDictionaryString@,System.Xml.XmlDictionaryString@)">
            <summary>
            Try to resolve an types <see cref="M:Cqrs.Services.BasicServiceParameterResolver`2.TryResolveType(System.Type,System.Type,System.Runtime.Serialization.DataContractResolver,System.Xml.XmlDictionaryString@,System.Xml.XmlDictionaryString@)"/> fails to.
            </summary>
            <param name="dataContractType">The type to map.</param>
            <param name="declaredType">The type declared in the data contract.</param>
            <param name="knownTypeResolver">The known type resolver.</param>
            <param name="typeName">The xsi:type name.</param>
            <param name="typeNamespace">The xsi:type namespace.</param>
            <returns>true if mapping succeeded; otherwise, false.</returns>
        </member>
        <member name="M:Cqrs.Services.BasicServiceParameterResolver`2.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
            <summary>
            Maps the specified xsi:type name and namespace to a data contract type during deserialization.
            </summary>
            <returns>
            The type the xsi:type name and namespace is mapped to. 
            </returns>
            <param name="typeName">The xsi:type name to map.</param>
            <param name="typeNamespace">The xsi:type namespace to map.</param>
            <param name="declaredType">The type declared in the data contract.</param>
            <param name="knownTypeResolver">The known type resolver.</param>
        </member>
        <member name="M:Cqrs.Services.BasicServiceParameterResolver`2.ResolveUnResolvedName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
            <summary>
            Try to resolve an types <see cref="M:Cqrs.Services.BasicServiceParameterResolver`2.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)"/> fails to.
            </summary>
            <returns>
            The type the xsi:type name and namespace is mapped to. 
            </returns>
            <param name="typeName">The xsi:type name to map.</param>
            <param name="typeNamespace">The xsi:type namespace to map.</param>
            <param name="declaredType">The type declared in the data contract.</param>
            <param name="knownTypeResolver">The known type resolver.</param>
        </member>
        <member name="P:Cqrs.Services.BasicServiceParameterResolver`2.TokenResolver">
            <summary>
            The <see cref="T:Cqrs.Services.IServiceParameterResolver"/> that has information about resolving authentication tokens such as <typeparamref name="TAuthenticationToken"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Services.BasicServiceParameterResolver`2.EventDataResolver">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Services.IEventDataResolver"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Services.BasicServiceParameterResolver`2.ServiceNamespace">
            <summary>
            The Service Name included in all <see cref="T:System.Type"/> resolution information.
            </summary>
        </member>
        <member name="T:Cqrs.Services.EventService`1">
            <summary>
            A WCF <see cref="T:System.ServiceModel.ServiceContractAttribute">ServiceContract</see> that provides read-only access to <see cref="T:Cqrs.Events.IEventStore`1"/> <see cref="T:Cqrs.Events.IEvent`1">events</see>
            raised with the same <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="T:Cqrs.Services.IEventService`1">
            <summary>
            A WCF <see cref="T:System.ServiceModel.ServiceContractAttribute">ServiceContract</see> that provides read-only access to <see cref="T:Cqrs.Events.IEventStore`1"/> <see cref="T:Cqrs.Events.IEvent`1">events</see>
            raised with the same <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Services.IEventService`1.GetEventData(Cqrs.Services.IServiceRequestWithData{`0,System.Guid})">
            <summary>
            Get all <see cref="T:Cqrs.Events.IEvent`1">events</see>
            raised with the same <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/>.
            </summary>
            <param name="serviceRequest">The <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/> of the <see cref="T:Cqrs.Events.IEvent`1">events</see> to find.</param>
        </member>
        <member name="M:Cqrs.Services.EventService`1.#ctor(Cqrs.Events.IEventStore{`0},cdmdotnet.Logging.ILogger,cdmdotnet.Logging.ICorrelationIdHelper,Cqrs.Authentication.IAuthenticationTokenHelper{`0})">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Services.EventService`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Services.EventService`1.GetEventData(Cqrs.Services.IServiceRequestWithData{`0,System.Guid})">
            <summary>
            Get all <see cref="T:Cqrs.Events.IEvent`1">events</see>
            raised with the same <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/>.
            </summary>
            <param name="serviceRequest">The <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/> of the <see cref="T:Cqrs.Events.IEvent`1">events</see> to find.</param>
        </member>
        <member name="M:Cqrs.Services.EventService`1.OnGetEventData(Cqrs.Services.IServiceRequestWithData{`0,System.Guid})">
            <summary>
            Executed before calling the <see cref="M:Cqrs.Events.IEventStore`1.Get(System.Type,System.Guid,System.Boolean,System.Int32)"/> method on <see cref="P:Cqrs.Services.EventService`1.EventStore"/>
            in <see cref="M:Cqrs.Services.EventService`1.GetEventData(Cqrs.Services.IServiceRequestWithData{`0,System.Guid})"/>.
            </summary>
            <param name="serviceRequest">The original <see cref="T:Cqrs.Services.IServiceRequestWithData`2"/>.</param>
        </member>
        <member name="M:Cqrs.Services.EventService`1.OnGotEventData(Cqrs.Services.IServiceRequestWithData{`0,System.Guid},System.Collections.Generic.IEnumerable{Cqrs.Events.EventData})">
            <summary>
            Executed after calling the <see cref="M:Cqrs.Events.IEventStore`1.Get(System.Type,System.Guid,System.Boolean,System.Int32)"/> method on <see cref="P:Cqrs.Services.EventService`1.EventStore"/>
            in <see cref="M:Cqrs.Services.EventService`1.GetEventData(Cqrs.Services.IServiceRequestWithData{`0,System.Guid})"/>.
            </summary>
            <param name="serviceRequest">The original <see cref="T:Cqrs.Services.IServiceRequestWithData`2"/>.</param>
            <param name="results">The collection of <see cref="T:Cqrs.Events.IEvent`1">events</see> from the <see cref="P:Cqrs.Services.EventService`1.EventStore"/>.</param>
        </member>
        <member name="M:Cqrs.Services.EventService`1.CompleteResponse``1(``0)">
            <summary>
            Sets the <see cref="P:Cqrs.Services.IServiceResponse.CorrelationId"/> on the provided <paramref name="serviceResponse"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Services.EventService`1.EventStore">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Events.IEventStore`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Services.EventService`1.AuthenticationTokenHelper">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Authentication.IAuthenticationTokenHelper`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Services.EventService`1.CorrelationIdHelper">
            <summary>
            Gets or sets the <see cref="T:cdmdotnet.Logging.ILogger"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Services.EventService`1.Logger">
            <summary>
            Gets or sets the <see cref="T:cdmdotnet.Logging.ILogger"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Services.IServiceRequest`1">
            <summary>
            A request message envelope that holds authentication and correlation information used when making public API requests.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type">type</see> of authentication token used.</typeparam>
        </member>
        <member name="P:Cqrs.Services.IServiceRequest`1.AuthenticationToken">
            <summary>
            The authentication token used to identify the requester.
            </summary>
        </member>
        <member name="P:Cqrs.Services.IServiceRequest`1.CorrelationId">
            <summary>
            The correlation id used to group together events and notifications.
            </summary>
        </member>
        <member name="T:Cqrs.Services.IServiceRequestWithData`2">
            <summary>
            A <see cref="T:Cqrs.Services.IServiceRequest`1">request message envelope</see> that holds authentication, correlation information as well as request data used when making public API requests.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type">type</see> of authentication token used.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type">type</see> of data sent along with the request to act upon/with.</typeparam>
        </member>
        <member name="P:Cqrs.Services.IServiceRequestWithData`2.Data">
            <summary>
            The data sent along with the request to act upon/with.
            </summary>
        </member>
        <member name="T:Cqrs.Services.IServiceResponse">
            <summary>
            A response message envelope that holds request state and correlation information in response to using public API requests.
            </summary>
        </member>
        <member name="P:Cqrs.Services.IServiceResponse.State">
            <summary>
            The state of the request.
            </summary>
        </member>
        <member name="P:Cqrs.Services.IServiceResponse.CorrelationId">
            <summary>
            The correlation id used to group together events and notifications.
            </summary>
        </member>
        <member name="T:Cqrs.Services.IServiceResponseWithResultData`1">
            <summary>
            A <see cref="T:Cqrs.Services.IServiceResponse">response message envelope</see> that holds request state, correlation information as well as the response data returned from making a public API request.
            </summary>
            <typeparam name="TResultData">The <see cref="T:System.Type">type</see> of data returned from making a public API request.</typeparam>
        </member>
        <member name="P:Cqrs.Services.IServiceResponseWithResultData`1.ResultData">
            <summary>
            The data returned from making a public API request.
            </summary>
        </member>
        <member name="T:Cqrs.Services.IUnitOfWorkService">
            <summary>
            Provides a basic container to control how the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> is accessed.
            </summary>
        </member>
        <member name="M:Cqrs.Services.IUnitOfWorkService.SetCommitter(System.Object)">
            <summary>
            Informs the service of the object that will be committing the UnitOfWork.
            </summary>
            <returns>
            true if the provided <paramref name="commiter"/> is accepted as the committer, false otherwise.
            </returns>
        </member>
        <member name="M:Cqrs.Services.IUnitOfWorkService.Commit(System.Object)">
            <summary>
            Commits the UnitOfWork if the provided <paramref name="commiter"/> is the Committer.
            </summary>
            <returns>
            true if the provided <paramref name="commiter"/> is the Committer, false otherwise.
            </returns>
        </member>
        <member name="T:Cqrs.Services.IVersionedServiceResponse">
            <summary>
            A <see cref="T:Cqrs.Services.IServiceResponse"/> that provides version information.
            </summary>
        </member>
        <member name="P:Cqrs.Services.IVersionedServiceResponse.Version">
            <summary>
            The version of the data being returned
            </summary>
        </member>
        <member name="T:Cqrs.Services.ServiceChannelFactory`1">
            <summary>
            A factory that creates channels of different types that are used by clients to send messages to variously configured service endpoints.
            </summary>
            <typeparam name="TService">The <see cref="T:System.Type"/> of service this <see cref="T:System.ServiceModel.ChannelFactory"/> is for.</typeparam>
        </member>
        <member name="M:Cqrs.Services.ServiceChannelFactory`1.#ctor(System.String)">
            <summary>
            Instantiates a new instance of the <see cref="T:Cqrs.Services.ServiceChannelFactory`1"/> class with a specified endpoint configuration name.
            </summary>
            <param name="endpointConfigurationName">The configuration name used for the endpoint.</param>
        </member>
        <member name="M:Cqrs.Services.ServiceChannelFactory`1.AttachDataContractResolver(System.ServiceModel.Description.ServiceEndpoint)">
            <summary>
            Uses <see cref="M:Cqrs.Services.WcfDataContractResolverConfiguration.GetDataContracts``1(System.String)"/>
            to find <see cref="T:System.Runtime.Serialization.DataContractResolver">resolvers</see> to automatically attach to each
            <see cref="T:System.ServiceModel.Description.OperationDescription"/> in <see cref="P:System.ServiceModel.Description.ContractDescription.Operations"/> of <see cref="P:System.ServiceModel.Description.ServiceEndpoint.Contract"/> of the provided <paramref name="endpoint"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Services.ServiceChannelFactory`1.RegisterDataContracts">
            <summary>
            Register any additional <see cref="T:System.Runtime.Serialization.DataContractResolver">resolvers</see>.
            </summary>
        </member>
        <member name="T:Cqrs.Services.ServiceParameterResolver`2">
            <summary>
            A <see cref="T:Cqrs.Services.BasicServiceParameterResolver`2"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Services.ServiceParameterResolver`2.#ctor(Cqrs.Services.ISingleSignOnTokenResolver,Cqrs.Services.IEventDataResolver)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Services.ServiceParameterResolver`2"/>
            </summary>
        </member>
        <member name="T:Cqrs.Services.ServiceRequest`1">
            <summary>
            A request message envelope that holds authentication and correlation information used when making public API requests.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type">type</see> of authentication token used.</typeparam>
        </member>
        <member name="P:Cqrs.Services.ServiceRequest`1.AuthenticationToken">
            <summary>
            The authentication token used to identify the requester.
            </summary>
        </member>
        <member name="P:Cqrs.Services.ServiceRequest`1.CorrelationId">
            <summary>
            The correlation id used to group together events and notifications.
            </summary>
        </member>
        <member name="T:Cqrs.Services.ServiceRequestWithData`2">
            <summary>
            A <see cref="T:Cqrs.Services.IServiceRequest`1">request message envelope</see> that holds authentication, correlation information as well as request data used when making public API requests.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type">type</see> of authentication token used.</typeparam>
            <typeparam name="TData">The <see cref="T:System.Type">type</see> of data sent along with the request to act upon/with.</typeparam>
        </member>
        <member name="P:Cqrs.Services.ServiceRequestWithData`2.Data">
            <summary>
            The data sent along with the request to act upon/with.
            </summary>
        </member>
        <member name="T:Cqrs.Services.ServiceResponse">
            <summary>
            A response message envelope that holds request state and correlation information in response to using public API requests.
            </summary>
        </member>
        <member name="M:Cqrs.Services.ServiceResponse.#ctor">
            <summary>
            Instantiate a new instance of the <see cref="T:Cqrs.Services.ServiceResponse"/> class.
            </summary>
        </member>
        <member name="P:Cqrs.Services.ServiceResponse.State">
            <summary>
            The state of the request.
            </summary>
        </member>
        <member name="P:Cqrs.Services.ServiceResponse.CorrelationId">
            <summary>
            The correlation id used to group together events and notifications.
            </summary>
        </member>
        <member name="P:Cqrs.Services.ServiceResponse.Version">
            <summary>
            The version of the data being returned
            </summary>
        </member>
        <member name="T:Cqrs.Services.ServiceResponseStateType">
            <summary>
            The response state of a given request.
            </summary>
        </member>
        <member name="F:Cqrs.Services.ServiceResponseStateType.Unknown">
            <summary>
            The state is unknown.
            </summary>
        </member>
        <member name="F:Cqrs.Services.ServiceResponseStateType.Succeeded">
            <summary>
            The request succeeded in being placed.
            </summary>
        </member>
        <member name="F:Cqrs.Services.ServiceResponseStateType.FailedWithAFatalException">
            <summary>
            The request failed with a fatal <see cref="T:System.Exception"/>.
            </summary>
        </member>
        <member name="F:Cqrs.Services.ServiceResponseStateType.FailedWithAnUnexpectedException">
            <summary>
            The request failed with an unknown, non-fatal <see cref="T:System.Exception"/>.
            </summary>
        </member>
        <member name="F:Cqrs.Services.ServiceResponseStateType.FailedAuthentication">
            <summary>
            The request failed to be authenticated.
            </summary>
        </member>
        <member name="F:Cqrs.Services.ServiceResponseStateType.FailedAuthorisation">
            <summary>
            The request failed to be authorised.
            </summary>
        </member>
        <member name="F:Cqrs.Services.ServiceResponseStateType.FailedValidation">
            <summary>
            The request failed validation.
            </summary>
        </member>
        <member name="F:Cqrs.Services.ServiceResponseStateType.AggregateNotFound">
            <summary>
            The request failed as the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> was not found.
            </summary>
        </member>
        <member name="F:Cqrs.Services.ServiceResponseStateType.EntityNotFound">
            <summary>
            The request failed as the <see cref="T:Cqrs.Entities.IEntity"/> was not found.
            </summary>
        </member>
        <member name="F:Cqrs.Services.ServiceResponseStateType.SagaNotFound">
            <summary>
            The request failed as the <see cref="T:Cqrs.Domain.Saga`1"/> was not found.
            </summary>
        </member>
        <member name="T:Cqrs.Services.ServiceResponseWithResultData`1">
            <summary>
            A <see cref="T:Cqrs.Services.IServiceResponse">response message envelope</see> that holds request state, correlation information as well as the response data returned from making a public API request.
            </summary>
            <typeparam name="TResultData">The <see cref="T:System.Type">type</see> of data returned from making a public API request.</typeparam>
        </member>
        <member name="M:Cqrs.Services.ServiceResponseWithResultData`1.#ctor">
            <summary>
            Instantiate a new instance of the <see cref="T:Cqrs.Services.ServiceResponseWithResultData`1"/> class.
            </summary>
        </member>
        <member name="M:Cqrs.Services.ServiceResponseWithResultData`1.#ctor(`0)">
            <summary>
            Instantiate a new instance of the <see cref="T:Cqrs.Services.ServiceResponseWithResultData`1"/> class providing <paramref name="resultData"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Services.ServiceResponseWithResultData`1.ResultData">
            <summary>
            The data returned from making a public API request.
            </summary>
        </member>
        <member name="T:Cqrs.Services.UnitOfWorkService`1">
            <summary>
            Provides a basic container to control how the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/> is accessed.
            </summary>
        </member>
        <member name="M:Cqrs.Services.UnitOfWorkService`1.#ctor(Cqrs.Domain.IUnitOfWork{`0})">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Services.UnitOfWorkService`1"/>.
            </summary>
            <param name="unitOfWork"></param>
        </member>
        <member name="M:Cqrs.Services.UnitOfWorkService`1.SetCommitter(System.Object)">
            <summary>
            Informs the service of the object that will be committing the <see cref="P:Cqrs.Services.UnitOfWorkService`1.UnitOfWork"/>.
            </summary>
            <returns>
            true if the provided <paramref name="commiter"/> is accepted as the committer, false otherwise.
            </returns>
        </member>
        <member name="M:Cqrs.Services.UnitOfWorkService`1.Commit(System.Object)">
            <summary>
            Commits the <see cref="P:Cqrs.Services.UnitOfWorkService`1.UnitOfWork"/> if the provided <paramref name="commiter"/> is the <see cref="P:Cqrs.Services.UnitOfWorkService`1.Committer"/>.
            </summary>
            <returns>
            true if the provided <paramref name="commiter"/> is the <see cref="P:Cqrs.Services.UnitOfWorkService`1.Committer"/>, false otherwise.
            </returns>
        </member>
        <member name="P:Cqrs.Services.UnitOfWorkService`1.UnitOfWork">
            <summary>
            Gets or set the <see cref="T:Cqrs.Domain.IUnitOfWork`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Services.UnitOfWorkService`1.Committer">
            <summary>
            Gets or set the object that wants to control the <see cref="P:Cqrs.Services.UnitOfWorkService`1.UnitOfWork"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Services.WcfDataContractResolverConfiguration">
            <summary>
            Configuration information for setting up WCF <see cref="T:System.Runtime.Serialization.DataContractResolver">resolvers</see>.
            </summary>
        </member>
        <member name="M:Cqrs.Services.WcfDataContractResolverConfiguration.#ctor">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Services.WcfDataContractResolverConfiguration"/>
            </summary>
        </member>
        <member name="M:Cqrs.Services.WcfDataContractResolverConfiguration.RegisterDataContract``2(System.String,Cqrs.Services.WcfDataContractResolverConfiguration.RegistrationHandling)">
            <summary>
            Register the <typeparamref name="TDataContract"/> to use for the operation named <paramref name="operationName"/> for the <typeparamref name="TService"/>.
            </summary>
            <typeparam name="TService">The <see cref="T:System.Type"/> of service.</typeparam>
            <typeparam name="TDataContract">The <see cref="T:System.Type"/> of the resolver.</typeparam>
            <param name="operationName">The name of the operation.</param>
            <param name="registrationHandling">Defaults to <see cref="F:Cqrs.Services.WcfDataContractResolverConfiguration.RegistrationHandling.Replace"/></param>
        </member>
        <member name="M:Cqrs.Services.WcfDataContractResolverConfiguration.GetDataContracts``1(System.String)">
            <summary>
            Gets the <see cref="T:System.Type"/> of <see cref="T:System.Runtime.Serialization.DataContractResolver"/> for the operation named <paramref name="operationName"/>
            of the <typeparamref name="TService"/>
            </summary>
            <typeparam name="TService">The <see cref="T:System.Type"/> of service.</typeparam>
            <param name="operationName">The name of the operation.</param>
        </member>
        <member name="P:Cqrs.Services.WcfDataContractResolverConfiguration.Current">
            <summary>
            The current instance of <see cref="T:Cqrs.Services.WcfDataContractResolverConfiguration"/> to use.
            </summary>
        </member>
        <member name="P:Cqrs.Services.WcfDataContractResolverConfiguration.DataContracts">
            <summary>
            Gets or set the data contracts for the system to use.
            </summary>
        </member>
        <member name="T:Cqrs.Services.WcfDataContractResolverConfiguration.RegistrationHandling">
            <summary>
            The type of registration action to take
            </summary>
        </member>
        <member name="F:Cqrs.Services.WcfDataContractResolverConfiguration.RegistrationHandling.Replace">
            <summary>
            Add any new, and replace any existing.
            </summary>
        </member>
        <member name="F:Cqrs.Services.WcfDataContractResolverConfiguration.RegistrationHandling.ThrowExceptionOnDuplicate">
            <summary>
            Throw an <see cref="T:System.Exception"/> if one already exists.
            </summary>
        </member>
        <member name="F:Cqrs.Services.WcfDataContractResolverConfiguration.RegistrationHandling.Nothing">
            <summary>
            Keep the existing one and don't do anything.
            </summary>
        </member>
        <member name="T:Cqrs.Snapshots.ISnapshotStore">
            <summary>
            Stores the most recent <see cref="T:Cqrs.Snapshots.Snapshot">snapshots</see> for replay and <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> rehydration on a <see cref="T:Cqrs.Snapshots.SnapshotAggregateRoot`2"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Snapshots.ISnapshotStore.Get``1(System.Guid)">
            <summary>
            Get the latest <see cref="T:Cqrs.Snapshots.Snapshot"/> from storage.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to find a snapshot for.</typeparam>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to get the most recent <see cref="T:Cqrs.Snapshots.Snapshot"/> of.</param>
            <returns>The most recent <see cref="T:Cqrs.Snapshots.Snapshot"/> of</returns>
        </member>
        <member name="M:Cqrs.Snapshots.ISnapshotStore.Save(Cqrs.Snapshots.Snapshot)">
            <summary>
            Saves the provided <paramref name="snapshot"/> into storage.
            </summary>
            <param name="snapshot">the <see cref="T:Cqrs.Snapshots.Snapshot"/> to save and store.</param>
        </member>
        <member name="T:Cqrs.Domain.Factories.AggregateFactory">
            <summary>
            A factory for creating instances of aggregates.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Factories.AggregateFactory.#ctor(Cqrs.Configuration.IDependencyResolver,cdmdotnet.Logging.ILogger)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Domain.Factories.AggregateFactory"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Factories.AggregateFactory.Create``1(System.Nullable{System.Guid},System.Boolean)">
            <summary>
            Creates instance of <typeparamref name="TAggregate"/>.
            </summary>
            <typeparam name="TAggregate">The <see cref="T:System.Type"/> of the aggregate to create.</typeparam>
            <param name="rsn">The identifier of the aggregate to create an instance of if an existing aggregate.</param>
            <param name="tryDependencyResolutionFirst">Indicates the use of <see cref="T:Cqrs.Configuration.IDependencyResolver"/> should be tried first.</param>
        </member>
        <member name="M:Cqrs.Domain.Factories.AggregateFactory.Create(System.Type,System.Nullable{System.Guid},System.Boolean)">
            <summary>
            Creates instance of type <paramref name="aggregateType"/>
            </summary>
            <param name="aggregateType">The <see cref="T:System.Type"/> of the aggregate to create.</param>
            <param name="rsn">The identifier of the aggregate to create an instance of if an existing aggregate.</param>
            <param name="tryDependencyResolutionFirst">Indicates the use of <see cref="T:Cqrs.Configuration.IDependencyResolver"/> should be tried first.</param>
        </member>
        <member name="P:Cqrs.Domain.Factories.AggregateFactory.DependencyResolver">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Configuration.IDependencyResolver"/> used.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Factories.AggregateFactory.Logger">
            <summary>
            Gets or sets the <see cref="T:cdmdotnet.Logging.ILogger"/> used.
            </summary>
        </member>
        <member name="T:Cqrs.Snapshots.Snapshot">
            <summary>
            Holds state information about an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> for fast rehydration.
            </summary>
        </member>
        <member name="P:Cqrs.Snapshots.Snapshot.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> this holds information about.
            </summary>
        </member>
        <member name="P:Cqrs.Snapshots.Snapshot.Version">
            <summary>
            The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> was at when this snapshot was taken.
            </summary>
        </member>
        <member name="T:Cqrs.Snapshots.SnapshotAggregateRoot`2">
            <summary>
            An <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that supports <see cref="T:Cqrs.Snapshots.Snapshot">snapshots</see> for optimised rehydration.
            </summary>
            <typeparam name="TAuthenticationToken"></typeparam>
            <typeparam name="TSnapshot"></typeparam>
        </member>
        <member name="M:Cqrs.Snapshots.SnapshotAggregateRoot`2.GetSnapshot">
            <summary>
            Calls <see cref="M:Cqrs.Snapshots.SnapshotAggregateRoot`2.CreateSnapshot"/> and applies the <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of this instance to the <typeparamref name="TSnapshot"/> result.
            </summary>
        </member>
        <member name="M:Cqrs.Snapshots.SnapshotAggregateRoot`2.Restore(`1)">
            <summary>
            Sets the <see cref="P:Cqrs.Domain.IAggregateRoot`1.Id"/> of this instance from <see cref="P:Cqrs.Snapshots.Snapshot.Id"/> the provided <paramref name="snapshot"/>,
            sets the <see cref="P:Cqrs.Domain.IAggregateRoot`1.Version"/> of this instance from  <see cref="P:Cqrs.Snapshots.Snapshot.Version"/> the provided <paramref name="snapshot"/>,
            then calls <see cref="M:Cqrs.Snapshots.SnapshotAggregateRoot`2.RestoreFromSnapshot(`1)"/>
            </summary>
            <param name="snapshot">The <typeparamref name="TSnapshot"/> to rehydrate this instance from.</param>
        </member>
        <member name="M:Cqrs.Snapshots.SnapshotAggregateRoot`2.CreateSnapshot">
            <summary>
            Create a <typeparamref name="TSnapshot"/> of the current state of this instance.
            </summary>
        </member>
        <member name="M:Cqrs.Snapshots.SnapshotAggregateRoot`2.RestoreFromSnapshot(`1)">
            <summary>
            Rehydrate this instance from the provided <paramref name="snapshot"/>.
            </summary>
            <param name="snapshot">The <typeparamref name="TSnapshot"/> to rehydrate this instance from.</param>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.AggregateNotFoundException`2">
            <summary>
            The <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> requested was not found.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.</typeparam>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.AggregateNotFoundException`2.#ctor(System.Guid)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.AggregateNotFoundException`2"/> with the provided identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.AggregateNotFoundException`2.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.
            </summary>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.AggregateNotFoundException`2.AggregateType">
            <summary>
            The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.
            </summary>
        </member>
        <member name="T:Cqrs.Domain.Exceptions.ConcurrencyException">
            <summary>
            An <see cref="T:Cqrs.Events.IEvent`1"/> was processed out of order or an expected <see cref="T:Cqrs.Events.IEvent`1"/> was not found.
            </summary>
        </member>
        <member name="M:Cqrs.Domain.Exceptions.ConcurrencyException.#ctor(System.Guid)">
            <summary>
            Instantiate a new instance of <see cref="T:Cqrs.Domain.Exceptions.ConcurrencyException"/> with the provided identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had a concurrency issue.
            </summary>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that wasn't found.</param>
        </member>
        <member name="P:Cqrs.Domain.Exceptions.ConcurrencyException.Id">
            <summary>
            The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> that had a concurrency issue.
            </summary>
        </member>
        <member name="T:Cqrs.Bus.InProcessBus`1">
            <summary>
            An in process command bus 
            (<see cref="T:Cqrs.Commands.ICommandPublisher`1"/> and <see cref="T:Cqrs.Commands.ICommandReceiver`1"/>)
            event bus
            (<see cref="T:Cqrs.Events.IEventPublisher`1"/> and <see cref="T:Cqrs.Events.IEventHandler`3"/>)
            as well as a <see cref="T:Cqrs.Bus.IEventHandlerRegistrar"/> and <see cref="T:Cqrs.Bus.ICommandHandlerRegistrar"/> that requires no networking.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.#ctor(Cqrs.Authentication.IAuthenticationTokenHelper{`0},cdmdotnet.Logging.ICorrelationIdHelper,Cqrs.Configuration.IDependencyResolver,cdmdotnet.Logging.ILogger,Cqrs.Configuration.IConfigurationManager,Cqrs.Bus.IBusHelper)">
            <summary>
            Instantiates a new instance of the <see cref="T:Cqrs.Bus.InProcessBus`1"/> class.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PrepareCommand``1(``0)">
            <summary>
            Sets the
            <see cref="P:Cqrs.Messages.IMessageWithAuthenticationToken`1.AuthenticationToken"/>,
            <see cref="P:Cqrs.Messages.IMessage.CorrelationId"/>,
            <see cref="P:Cqrs.Messages.IMessage.OriginatingFramework"/> to "Built-In" and
            adds a value of "Built-In" to the <see cref="P:Cqrs.Messages.IMessage.Frameworks"/>
            if not already done so
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PrepareAndValidateCommand``1(``0,Cqrs.Bus.RouteHandlerDelegate@)">
            <summary>
            Locates a suitable <see cref="T:Cqrs.Commands.ICommandValidator`2"/> to validate the provided <paramref name="command"/> and validates the provided <paramref name="command"/> if one is located
            Calls <see cref="M:Cqrs.Bus.InProcessBus`1.PrepareCommand``1(``0)"/>
            Checks if the provided <paramref name="command"/> is required to be processed
            Locates a single <see cref="T:Cqrs.Bus.RouteHandlerDelegate">command handler</see> for the provided <paramref name="command"/>
            </summary>
            <returns>
            False if a suitable <see cref="T:Cqrs.Commands.ICommandValidator`2"/> is located and the provided <paramref name="command"/> fails validation,
            False if no <see cref="T:Cqrs.Bus.RouteHandlerDelegate">command handler</see> is found but the command isn't required to be handled,
            True otherwise.
            </returns>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.Cqrs#Commands#ICommandPublisher{TAuthenticationToken}#Publish``1(``0)">
            <summary>
            Publishes the provided <paramref name="command"/> on the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.Send``1(``0)">
            <summary>
            Publishes the provided <paramref name="command"/> on the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.Cqrs#Commands#ICommandPublisher{TAuthenticationToken}#Publish``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Publishes the provided <paramref name="commands"/> on the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.Send``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Publishes the provided <paramref name="commands"/> on the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits until the specified condition is satisfied an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Sends the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to send.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.Publish``1(``0)">
            <summary>
            Publishes the provided <paramref name="event"/> on the event bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.Publish``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Publishes the provided <paramref name="events"/> on the event bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits until the specified condition is satisfied an event of <typeparamref name="TEvent"/>
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.Int32,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
            <summary>
            Publishes the provided <paramref name="command"></paramref> and waits for an event of <typeparamref name="TEvent"/> or exits if the specified timeout is expired.
            </summary>
            <param name="command">The <typeparamref name="TCommand"/> to publish.</param>
            <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent"/> that is desired, return null to keep trying.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1"/> that the event is expected to be returned on.</param>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)">
            <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.RegisterHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.RegisterGlobalEventHandler``1(System.Action{``0},System.Boolean)">
            <summary>
            Register an event handler that will listen and respond to all events.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.ReceiveCommand(Cqrs.Commands.ICommand{`0})">
            <summary>
            Receives a <see cref="T:Cqrs.Commands.ICommand`1"/> from the command bus.
            </summary>
        </member>
        <member name="M:Cqrs.Bus.InProcessBus`1.ReceiveEvent(Cqrs.Events.IEvent{`0})">
            <summary>
            Receives an <see cref="T:Cqrs.Events.IEvent`1"/> from the event bus.
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.Routes">
            <summary>
            Gets or sets the Route Manager
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.AuthenticationTokenHelper">
            <summary>
            Gets or sets the Authentication Token Helper
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.CorrelationIdHelper">
            <summary>
            Gets or sets the CorrelationId Helper
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.DependencyResolver">
            <summary>
            Gets or sets the Dependency Resolver
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.Logger">
            <summary>
            Gets or sets the Logger
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.ConfigurationManager">
            <summary>
            Gets or sets the Configuration Manager
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.BusHelper">
            <summary>
            Gets or sets the Bus Helper
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.EventWaits">
            <summary>
            Gets or sets the current list of events waiting to be evaluated for <see cref="M:Cqrs.Bus.InProcessBus`1.PublishAndWait``2(``0,Cqrs.Events.IEventReceiver{`0})"/>
            </summary>
        </member>
        <member name="P:Cqrs.Bus.InProcessBus`1.TelemetryHelper">
            <summary>
            Gets or sets the Telemetry Helper
            </summary>
        </member>
        <member name="T:Cqrs.Infrastructure.DelegateAdjuster">
            <summary>
            Adjusts <see cref="T:System.Linq.Expressions.Expression"/> using <see cref="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)"/>
            </summary>
        </member>
        <member name="M:Cqrs.Infrastructure.DelegateAdjuster.CastArgument``2(System.Linq.Expressions.Expression{System.Action{``1}})">
            <summary>
            If <typeparamref name="TDerived"/> equals <typeparamref name="TBase"/> then <paramref name="source"/> is compiled using <see cref="M:System.Linq.Expressions.Expression`1.Compile"/>
            Otherwise <paramref name="source"/> is converted to type <typeparamref name="TDerived"/> from <typeparamref name="TBase"/>
            </summary>
            <typeparam name="TBase">The source <see cref="T:System.Type"/>.</typeparam>
            <typeparam name="TDerived">The target <see cref="T:System.Type"/>.</typeparam>
            <param name="source">The delegate to adjust.</param>
        </member>
        <member name="T:Cqrs.Snapshots.ISnapshotStrategy`1">
            <summary>
            Provides information about the ability to make and get <see cref="T:Cqrs.Snapshots.Snapshot">snapshots</see>.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Snapshots.ISnapshotStrategy`1.ShouldMakeSnapShot(Cqrs.Domain.IAggregateRoot{`0})">
            <summary>
            Indicates if the provided <paramref name="aggregate"/> should have a <see cref="T:Cqrs.Snapshots.Snapshot"/> made.
            This does NOT indicate if the provided <paramref name="aggregate"/> can have a <see cref="T:Cqrs.Snapshots.Snapshot"/> made or not.
            </summary>
            <param name="aggregate">The <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to check.</param>
        </member>
        <member name="M:Cqrs.Snapshots.ISnapshotStrategy`1.IsSnapshotable(System.Type)">
            <summary>
            Indicates if the provided <paramref name="aggregateType"/> can have a <see cref="T:Cqrs.Snapshots.Snapshot"/> made or not.
            </summary>
            <param name="aggregateType">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to check.</param>
        </member>
        <member name="T:Cqrs.Infrastructure.PrivateReflectionDynamicObject">
            <summary>
            A universal wrapper around complex and primitive objects.
            </summary>
        </member>
        <member name="M:Cqrs.Infrastructure.PrivateReflectionDynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
            <summary>
            Calls <see cref="M:Cqrs.Infrastructure.PrivateReflectionDynamicObject.InvokeMemberOnType(System.Type,System.Object,System.String,System.Object[])"/> then passes the response to <see cref="M:Cqrs.Infrastructure.PrivateReflectionDynamicObject.WrapObjectIfNeeded(System.Object)"/>.
            </summary>
            <remarks>Called when a method is called.</remarks>
        </member>
        <member name="P:Cqrs.Infrastructure.PrivateReflectionDynamicObject.RealObject">
            <summary>
            The original/real <see cref="T:System.Object"/> this wraps.
            </summary>
        </member>
        <member name="M:Cqrs.Infrastructure.PrivateReflectionDynamicObjectExtensions.AsDynamic(System.Object)">
            <summary>
            Convert the provided <paramref name="object"/> into a safe to use <see cref="T:System.Dynamic.DynamicObject"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Snapshots.DefaultSnapshotStrategy`1">
            <summary>
            An <see cref="T:Cqrs.Snapshots.ISnapshotStrategy`1"/> that takes a snapshot every 15 versions.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of the authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Snapshots.DefaultSnapshotStrategy`1.IsSnapshotable(System.Type)">
            <summary>
            Indicates if the <paramref name="aggregateType"/> is able to be snapshotted by checking if the <paramref name="aggregateType"/>
            directly inherits <see cref="T:Cqrs.Snapshots.SnapshotAggregateRoot`2"/>
            </summary>
            <param name="aggregateType">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to check.</param>
        </member>
        <member name="M:Cqrs.Snapshots.DefaultSnapshotStrategy`1.ShouldMakeSnapShot(Cqrs.Domain.IAggregateRoot{`0})">
            <summary>
            Checks <see cref="M:Cqrs.Snapshots.DefaultSnapshotStrategy`1.IsSnapshotable(System.Type)"/> and if it is, also checks if the calculated version number would be exactly dividable by <see cref="M:Cqrs.Snapshots.DefaultSnapshotStrategy`1.GetSnapshotInterval"/>.
            </summary>
            <param name="aggregate">The <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to check.</param>
        </member>
        <member name="M:Cqrs.Snapshots.DefaultSnapshotStrategy`1.GetSnapshotInterval">
            <summary>
            Returns the value of <see cref="F:Cqrs.Snapshots.DefaultSnapshotStrategy`1.SnapshotInterval"/>.
            </summary>
        </member>
        <member name="T:Cqrs.Configuration.BusRegistrar">
            <summary>
            Triggers the <see cref="T:Cqrs.Bus.IEventHandlerRegistrar"/> and <see cref="T:Cqrs.Bus.ICommandHandlerRegistrar"/> if they are registered in the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.#ctor(Cqrs.Configuration.IDependencyResolver)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Configuration.BusRegistrar"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.Register(System.Type[])">
            <summary>
            Registers all <see cref="T:Cqrs.Events.IEventHandler"/> and <see cref="T:Cqrs.Commands.ICommandHandler`2"/> instances found in the <see cref="T:System.Reflection.Assembly"/> for each <see cref="T:System.Type"/> in <paramref name="typesFromAssemblyContainingMessages"/>.
            </summary>
            <param name="typesFromAssemblyContainingMessages">A collection of <see cref="T:System.Type"/> to track back to their containing <see cref="T:System.Reflection.Assembly"/> and scan.</param>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.Register(System.Boolean,System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}},System.Boolean,System.Type[])">
            <summary>
            Registers all <see cref="T:Cqrs.Messages.IHandler"/> instances found in the <see cref="T:System.Reflection.Assembly"/> for each <see cref="T:System.Type"/> in <paramref name="typesFromAssemblyContainingMessages"/>.
            </summary>
            <param name="trueForEventsFalseForCommands">Indicates if this is registers <see cref="T:Cqrs.Events.IEventHandler"/> or <see cref="T:Cqrs.Commands.ICommandHandler`2"/>.</param>
            <param name="resolveMessageHandlerInterface"><see cref="M:Cqrs.Configuration.BusRegistrar.ResolveEventHandlerInterface(System.Type)"/> or <see cref="M:Cqrs.Configuration.BusRegistrar.ResolveCommandHandlerInterface(System.Type)"/></param>
            <param name="skipCommandHandlers">Indicates if registering of <see cref="T:Cqrs.Commands.ICommandHandler`2"/> is enabled.</param>
            <param name="typesFromAssemblyContainingMessages">A collection of <see cref="T:System.Type"/> to track back to their containing <see cref="T:System.Reflection.Assembly"/> and scan.</param>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.InvokeHandler(System.Type,System.Boolean,System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}},System.Type)">
            <summary>
            Extract the <see cref="M:Cqrs.Bus.IHandlerRegistrar.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)"/> method of <see cref="P:Cqrs.Configuration.BusRegistrar.GetEventHandlerRegistrar"/> or <see cref="P:Cqrs.Configuration.BusRegistrar.GetCommandHandlerRegistrar"/>.
            Create an <see cref="T:System.Action"/> around the provided <paramref name="executorType"/>
            Then register the created <see cref="T:System.Action"/> using the extracted <see cref="M:Cqrs.Bus.IHandlerRegistrar.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)"/> method
            </summary>
            <param name="interface">The <see cref="T:System.Type"/> of <see cref="T:Cqrs.Messages.IHandler"/></param>
            <param name="trueForEventsFalseForCommands">Indicates if this is registers <see cref="T:Cqrs.Events.IEventHandler"/> or <see cref="T:Cqrs.Commands.ICommandHandler`2"/>.</param>
            <param name="resolveMessageHandlerInterface"><see cref="M:Cqrs.Configuration.BusRegistrar.ResolveEventHandlerInterface(System.Type)"/> or <see cref="M:Cqrs.Configuration.BusRegistrar.ResolveCommandHandlerInterface(System.Type)"/></param>
            <param name="executorType">The <see cref="T:System.Type"/> of the event handler that will do the handling</param>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.InvokeHandlerDelegate(System.Reflection.MethodInfo,System.Boolean,Cqrs.Configuration.HandlerDelegate)">
            <summary>
            Invokes <paramref name="handlerDelegate"/>, fetching the corresponding "HoldMessageLock" configuration setting 
            </summary>
            <param name="registerExecutorMethod">The <see cref="T:System.Reflection.MethodInfo"/> to use to invoke <paramref name="handlerDelegate"/>.</param>
            <param name="trueForEventsFalseForCommands">Indicates if this is registers <see cref="T:Cqrs.Events.IEventHandler"/> or <see cref="T:Cqrs.Commands.ICommandHandler`2"/>.</param>
            <param name="handlerDelegate">The actual <see cref="T:Cqrs.Configuration.HandlerDelegate"/> that gets executed.</param>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.BuildDelegateAction(System.Type,System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
            Builds a <see cref="T:Cqrs.Configuration.HandlerDelegate"/> that will resolve the provided <paramref name="executorType"/> and invoke the Handle method, when executed.
            </summary>
            <param name="executorType">The type of <see cref="T:Cqrs.Messages.IHandler"/> to resolve.&gt;</param>
            <param name="resolveMessageHandlerInterface">Not used.</param>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.BuildExecutorMethod(System.Reflection.MethodInfo,System.Type,System.Type)">
            <summary>
            Builds a method replacing the generic type with <paramref name="commandType"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.ResolveEventHandlerInterface(System.Type)">
            <summary>
            Finds all <see cref="T:System.Type"/> that implement <see cref="T:Cqrs.Events.IEventHandler`2"/> that are implemented by <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find all <see cref="T:Cqrs.Events.IEventHandler`2"/> of.</param>
        </member>
        <member name="M:Cqrs.Configuration.BusRegistrar.ResolveCommandHandlerInterface(System.Type)">
            <summary>
            Finds all <see cref="T:System.Type"/> that implement <see cref="T:Cqrs.Commands.ICommandHandler`2"/> that are implemented by <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find all <see cref="T:Cqrs.Commands.ICommandHandler`2"/> of.</param>
        </member>
        <member name="P:Cqrs.Configuration.BusRegistrar.DependencyResolver">
            <summary>
            Gets or set the <see cref="T:Cqrs.Configuration.IDependencyResolver"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.BusRegistrar.GetEventHandlerRegistrar">
            <summary>
            A <see cref="T:System.Func`3"/> to use in-place of <see cref="T:Cqrs.Bus.IEventHandlerRegistrar"/>
            </summary>
        </member>
        <member name="P:Cqrs.Configuration.BusRegistrar.GetCommandHandlerRegistrar">
            <summary>
            A <see cref="T:System.Func`3"/> to use in-place of <see cref="T:Cqrs.Bus.ICommandHandlerRegistrar"/>
            </summary>
        </member>
        <member name="T:Cqrs.Snapshots.SnapshotRepository`1">
            <summary>
            Provides basic repository methods for operations with instances of <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>
            utilising <see cref="T:Cqrs.Snapshots.Snapshot">snapshots</see> for optimised rehydration.
            </summary>
            <typeparam name="TAuthenticationToken">The <see cref="T:System.Type"/> of authentication token.</typeparam>
        </member>
        <member name="M:Cqrs.Snapshots.SnapshotRepository`1.#ctor(Cqrs.Snapshots.ISnapshotStore,Cqrs.Snapshots.ISnapshotStrategy{`0},Cqrs.Domain.IAggregateRepository{`0},Cqrs.Events.IEventStore{`0},Cqrs.Domain.Factories.IAggregateFactory)">
            <summary>
            Instantiates a new instance of <see cref="T:Cqrs.Snapshots.SnapshotRepository`1"/>.
            </summary>
        </member>
        <member name="M:Cqrs.Snapshots.SnapshotRepository`1.Save``1(``0,System.Nullable{System.Int32})">
            <summary>
            Calls <see cref="M:Cqrs.Snapshots.SnapshotRepository`1.TryMakeSnapshot(Cqrs.Domain.IAggregateRoot{`0})"/> then <see cref="M:Cqrs.Domain.IAggregateRepository`1.Save``1(``0,System.Nullable{System.Int32})"/> on <see cref="P:Cqrs.Snapshots.SnapshotRepository`1.Repository"/>.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregate">The <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to save and persist.</param>
            <param name="expectedVersion">The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is expected to be at.</param>
        </member>
        <member name="M:Cqrs.Snapshots.SnapshotRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})">
            <summary>
            Retrieves an <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> of type <typeparamref name="TAggregateRoot"/>,
            First using <see cref="M:Cqrs.Snapshots.SnapshotRepository`1.TryRestoreAggregateFromSnapshot``1(System.Guid,``0)"/>, otherwise via <see cref="M:Cqrs.Domain.IAggregateRepository`1.Get``1(System.Guid,System.Collections.Generic.IList{Cqrs.Events.IEvent{`0}})"/> on <see cref="P:Cqrs.Snapshots.SnapshotRepository`1.Repository"/>
            Then does rehydration.
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="aggregateId">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to retrieve.</param>
            <param name="events">
            A collection of <see cref="T:Cqrs.Events.IEvent`1"/> to replay on the retrieved <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.
            If null, the <see cref="T:Cqrs.Events.IEventStore`1"/> will be used to retrieve a list of <see cref="T:Cqrs.Events.IEvent`1"/> for you.
            </param>
        </member>
        <member name="M:Cqrs.Snapshots.SnapshotRepository`1.TryRestoreAggregateFromSnapshot``1(System.Guid,``0)">
            <summary>
            Calls <see cref="M:Cqrs.Snapshots.ISnapshotStrategy`1.IsSnapshotable(System.Type)"/> on <see cref="P:Cqrs.Snapshots.SnapshotRepository`1.SnapshotStrategy"/>
            If the <typeparamref name="TAggregateRoot"/> is snapshot-able <see cref="M:Cqrs.Snapshots.ISnapshotStore.Get``1(System.Guid)"/> is called on <see cref="P:Cqrs.Snapshots.SnapshotRepository`1.SnapshotStore"/>.
            The Restore method is then called on
            </summary>
            <typeparam name="TAggregateRoot">The <see cref="T:System.Type"/> of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/>.</typeparam>
            <param name="id">The identifier of the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to restore, since the <paramref name="aggregate"/> may be completely uninitialised.</param>
            <param name="aggregate">The <typeparamref name="TAggregateRoot"/></param>
            <returns>-1 if no restoration was made, otherwise version number the <typeparamref name="TAggregateRoot"/> was rehydrated to.</returns>
            <remarks>There may be more events after the snapshot that still need to rehydrated into the <typeparamref name="TAggregateRoot"/> after restoration.</remarks>
        </member>
        <member name="M:Cqrs.Snapshots.SnapshotRepository`1.TryMakeSnapshot(Cqrs.Domain.IAggregateRoot{`0})">
            <summary>
            Calls <see cref="M:Cqrs.Snapshots.ISnapshotStrategy`1.ShouldMakeSnapShot(Cqrs.Domain.IAggregateRoot{`0})"/> on <see cref="P:Cqrs.Snapshots.SnapshotRepository`1.SnapshotStrategy"/>
            If the <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> is snapshot-able <see cref="M:Cqrs.Snapshots.SnapshotAggregateRoot`2.GetSnapshot"/> is called
            The <see cref="P:Cqrs.Snapshots.Snapshot.Version"/> is calculated, finally <see cref="M:Cqrs.Snapshots.ISnapshotStore.Save(Cqrs.Snapshots.Snapshot)"/> is called on <see cref="P:Cqrs.Snapshots.SnapshotRepository`1.SnapshotStore"/>.
            </summary>
            <param name="aggregate">The <see cref="T:Cqrs.Domain.IAggregateRoot`1"/> to try and snapshot.</param>
        </member>
        <member name="P:Cqrs.Snapshots.SnapshotRepository`1.SnapshotStore">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Snapshots.ISnapshotStore"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Snapshots.SnapshotRepository`1.SnapshotStrategy">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Snapshots.ISnapshotStrategy`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Snapshots.SnapshotRepository`1.Repository">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Domain.IAggregateRepository`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Snapshots.SnapshotRepository`1.EventStore">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Events.IEventStore`1"/>.
            </summary>
        </member>
        <member name="P:Cqrs.Snapshots.SnapshotRepository`1.AggregateFactory">
            <summary>
            Gets or sets the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory"/>.
            </summary>
        </member>
    </members>
</doc>
